<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>接入NVBoard</title>
      <link href="/2025/11/12/%E6%8E%A5%E5%85%A5NVBoard/"/>
      <url>/2025/11/12/%E6%8E%A5%E5%85%A5NVBoard/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><html><head></head><body><h2 id="makefile">Makefile</h2><p>为了搞懂NVBoard是怎么工作的，先看一下它的构建规则是怎么样的</p><p>其构建规则在<code>/scripts/nvboard.mk</code>中，Makefile的一些补充知识</p><ol type="1"><li><p>自动变量:</p><p><code>$@</code>: 目标</p><p><code>$&lt;</code>: 第一个依赖</p><p><code>$^</code>: 所有依赖(去重)</p><p><code>$+</code>: 所有依赖(不去重)</p></li><li><p>命令前加<code>@</code>，不在终端中显示该命令，但仍会显示输出</p></li><li><p>内建变量:</p><p><code>CXX</code>: cpp编译器</p><p><code>CC</code>: c编译器</p><p><code>CPPFLAGS</code>: 编译器选项</p><p><code>CFLAGS</code></p></li><li><p>赋值</p><p><code>=</code>: 展开赋值(动态值),使用时才赋值</p><p><code>:=</code>: 立即赋值(静态值)</p><p><code>+=</code>: 追加赋值</p><p><code>?=</code>: 条件赋值，只有在没有被定义的时候才会赋值</p></li><li><p>同名目标的多个规则会合并</p></li><li><p>依赖中的变量会在读取Makefile时展开(编读边展开)，而规则中的变量会在使用时展开。而Makefile会读取完整个文件后再执行对应的规则</p></li><li><p>Makefile 默认的 target 是 file 中的第一个 target</p></li></ol><h2 id="接入nvboard流水灯">接入NVBoard(流水灯)</h2><h3 id="编写makefile">编写Makefile</h3><p>参考NVBoard/example中的Makefile，但有几点是要注意的</p><ol type="1"><li></li></ol></body></html>]]></content>
      
      
      <categories>
          
          <category> 一生一芯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一生一芯 </tag>
            
            <tag> Makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Projection Matrices and Least Squares</title>
      <link href="/2025/11/12/Projection-Matrices-and-Least-Squares/"/>
      <url>/2025/11/12/Projection-Matrices-and-Least-Squares/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><html><head></head><body><h1 id="投影projection">投影(Projection)</h1><h2 id="概要">概要</h2><p><img src="/2025/11/12/Projection-Matrices-and-Least-Squares/projectionConclusion.png"></p><h2 id="投影矩阵投影误差向量">投影矩阵、投影、误差向量</h2><p>目标: 找出向量b在空间S上的投影p，以及产生p的矩阵P</p><p>误差向量: <span class="math inline">\(e = b - p = A \hatx\)</span></p><p>tips: A 是空间 S 的基向量构成的矩阵</p><p>方法: 根据几何关系可以得到<span class="math inline">\(e\)</span>与空间S正交。描述一个空间的最好方法就是用<strong>基向量</strong>描述，<strong><em>把基向量放入矩阵A中，该矩阵的列空间即为空间S</em></strong>，由<span class="math inline">\(e \perp S\)</span>，得到<span class="math inline">\(e \inLN(S)\)</span>，即误差向量在S的左零空间中。</p><p>下图是图例: <img src="/2025/11/12/Projection-Matrices-and-Least-Squares/投影图例.png"></p><p>由上述关系可得:</p><p><span class="math display">\[\begin{aligned}A^\top (b - A\hat x) &amp;= 0 \\\hat x &amp;= (A^\top A)^{-1}A^\top b \\p &amp;= Ax = A(A^\top A)^{-1}A^\top b \\P &amp;= A(A^\top A)^{-1}A^\top\end{aligned}\]</span></p><h1 id="最小二乘法least-squares">最小二乘法(Least Squares)</h1><p>目的: <span class="math inline">\(Ax =b\)</span>有时候无解,我们为了找到最接近的(误差最小的解),可以去解<span class="math inline">\(A\hat x=p\)</span>,其中<span class="math inline">\(b = p + e\)</span></p><p><img src="/2025/11/12/Projection-Matrices-and-Least-Squares/最小二乘法图例.png" width="500"></p><p>上图是最直观的一幅图，有以下几点需要注意</p><ol type="1"><li>A是线性无关的列构成的矩阵，所以其零空间只有0</li><li>因为列空间和左零空间互为正交补空间，所以b能分解为<span class="math inline">\(p+e\)</span></li><li>将b投影到p的投影矩阵是P,而投影到e的投影矩阵是I-P</li></ol><p>第三点的证明:</p><p>我们已知<span class="math inline">\(b = p + e\)</span>,而<span class="math inline">\(p = Pb\)</span>,简单代数运算后得到<span class="math inline">\(e =(I-P)b\)</span>,然后再证明e在A的左零空间中.</p><p><span class="math display">\[\begin{aligned}P &amp;= A (A^T A)^{-1} A^T \\A^T P &amp;= A^T \bigl(A (A^T A)^{-1} A^T \bigr) \\&amp;= (A^T A)(A^T A)^{-1} A^T \\&amp;= A^T \\A^T(I-P) &amp;= A^T - A^T P = 0 \\A^T(I-P)\mathbf b &amp;= 0 \\\end{aligned}\]</span></p><p>另一个证明:</p><p><span class="math display">\[\begin{aligned}e &amp;= b - p \\Pe &amp; = P(b - p)\\&amp;= p - p \\&amp; = 0\end{aligned}\]</span> ## <span class="math inline">\(A^TA\)</span>的可逆性证明</p><p>前提条件: A的列向量是线性无关的</p><p>proof: 要证<span class="math inline">\(A^TA\)</span>可逆，即证<span class="math inline">\(A^TAx=0\)</span>的解只有零向量 <span class="math display">\[\begin{aligned}suppose:A^TAx &amp;= 0 \\x^TA^TAx &amp;=0 \\(Ax)^TAx &amp;=0 \\Ax = 0 \\\end{aligned}\]</span></p><p>最后得到只需要证明<span class="math inline">\(Ax=0\)</span>，但我们的前提条件是A的列向量之间是线性无关的，所以证毕</p><h2 id="补充">补充</h2><ol type="1"><li>若b在子空间S中，则<span class="math inline">\(Pb =b\)</span>。反之也成立。</li><li>若b垂直于子空间S，则<span class="math inline">\(Pb =0\)</span>。反之也成立。</li></ol><p>第一条证明:</p><p>因为b在子空间S中，所以b为列向量的线性组合，即<span class="math inline">\(b = Ax\)</span> <span class="math display">\[\begin{aligned}P &amp;= A(A^TA)^{-1}A^T \\Pb &amp;= A(A^TA)^{-1}A^Tb \\&amp;= A(A^TA)^{-1}A^TAx \\&amp;= A(A^TA)^{-1}(A^TA)x \\&amp;= Ax \\&amp;= b \\\end{aligned}\]</span></p><p>第二条证明:</p><p>因为b垂直于子空间S，则<span class="math inline">\(b \inS^\perp\)</span>，所以<span class="math inline">\(A^Tb = 0\)</span></p><p><span class="math display">\[\begin{aligned}P &amp;= A(A^TA)^{-1}A^T \\Pb &amp;= A(A^TA)^{-1}A^Tb \\&amp;= 0\end{aligned}\]</span></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随记2</title>
      <link href="/2025/11/12/%E9%9A%8F%E8%AE%B02/"/>
      <url>/2025/11/12/%E9%9A%8F%E8%AE%B02/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><html><head></head><body><p>路还很长，对自己不要太严格了，take it easy.</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 随记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随机信号处理-功率谱</title>
      <link href="/2025/11/12/%E9%9A%8F%E6%9C%BA%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86-%E5%8A%9F%E7%8E%87%E8%B0%B1/"/>
      <url>/2025/11/12/%E9%9A%8F%E6%9C%BA%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86-%E5%8A%9F%E7%8E%87%E8%B0%B1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><html><head></head><body><p>只为了考试！</p><h2 id="过程的一些数字特征">过程的一些数字特征</h2><ol type="1"><li>均值<ul><li>若功率谱连续则均值为0</li></ul></li><li>自相关函数和互相关函数<ul><li>自相关 <span class="math inline">\(R_{X}(\tau) =\mathbb{E}[X(t)X(t+\tau)]\)</span></li><li>互相关 <span class="math inline">\(R_{XY}(\tau) =\mathbb{E}[X(t)Y(t+\tau)]\)</span></li></ul></li><li>自相关系数<ul><li>def: <span class="math inline">\(\rho_X(\tau)=\frac{R_X(\tau)}{R_X(0)},\qquad\rho_X(0)=1\)</span></li></ul></li><li>方差/协方差<ul><li>方差计算公式: <span class="math inline">\(Var(X) = R_{X}(0) -m_{X}^2 = E[(X - E(X))^2]\)</span></li><li>协方差计算公式: <span class="math inline">\(\mathrm{Cov}(X,Y)=\mathbb{E}\!\left[(X-\mu_X)(Y-\mu_Y)\right]\)</span></li><li>自协方差和相关函数的关系: <span class="math inline">\(R_X(\tau) =m_X^2 + C_X(\tau)\)</span></li></ul></li><li>相关时间<ul><li>def: <span class="math inline">\(\tau_c=\int_{0}^{\infty}\rho_X(\tau)\,d\tau\)</span></li></ul></li><li>平均功率<ul><li><span class="math inline">\(P_{\text{avg}}=\mathbb{E}[X^2(t)]=R_X(0)\)</span></li></ul></li><li>总功率<ul><li><span class="math inline">\(P_{\text{total}}=P_{\text{DC}}+P_{\text{AC}}= m_X^2 + \big(R_X(0)-m_X^2\big)= m_X^2 + \sigma_X^2\)</span></li></ul></li><li>直流功率</li><li>交流功率</li></ol><p><img src="/2025/11/12/%E9%9A%8F%E6%9C%BA%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86-%E5%8A%9F%E7%8E%87%E8%B0%B1/功率分解.png" width="400"></p><p>proof(1):</p><h2 id="宽平稳过程">宽平稳过程</h2><p>经常用到的公式: 三角形的和差化积</p><h2 id="功率谱密度">功率谱密度</h2><p>常用性质: 频域时移</p><p>def: 对自相关函数/互相关函数做傅立叶变换得到功率谱密度</p><h2 id="白噪声">白噪声</h2><p><img src="/2025/11/12/%E9%9A%8F%E6%9C%BA%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86-%E5%8A%9F%E7%8E%87%E8%B0%B1/白噪声.png" width="400"></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 本科课程 </category>
          
          <category> 随机信号处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 本科课程 </tag>
            
            <tag> 随机信号处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识GTKWAVE</title>
      <link href="/2025/11/08/%E5%88%9D%E8%AF%86GTKWAVE/"/>
      <url>/2025/11/08/%E5%88%9D%E8%AF%86GTKWAVE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><html><head></head><body><h2 id="编写testbench生成仿真文件">编写testbench生成仿真文件</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="comment">// 包含顶层模块的头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Vtop.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"verilated.h"</span></span></span><br><span class="line"><span class="comment">// 生成vcd格式的仿真文件所需头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"verilated_vcd_c.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>{</span><br><span class="line">  VerilatedContext* contextp = <span class="keyword">new</span> VerilatedContext; <span class="comment">// 创建一个上下文对象</span></span><br><span class="line">  VerilatedVcdC *tfp = <span class="keyword">new</span> VerilatedVcdC; <span class="comment">//创建一个VCD对象指针</span></span><br><span class="line">  contextp-&gt;<span class="built_in">commandArgs</span>(argc, argv); </span><br><span class="line">  Vtop* top = <span class="keyword">new</span> Vtop{contextp}; <span class="comment">// 在heap上构造一个对象 {}列表初始化</span></span><br><span class="line">  contextp-&gt;<span class="built_in">traceEverOn</span>(<span class="literal">true</span>); <span class="comment">// 打开上下文追踪</span></span><br><span class="line">  top-&gt;<span class="built_in">trace</span>(tfp, <span class="number">0</span>);</span><br><span class="line">  tfp-&gt;<span class="built_in">open</span>(<span class="string">"wave.vcd"</span>); <span class="comment">//保存波形文件的位置</span></span><br><span class="line">  <span class="comment">// 若上下文标记未完成，则一直循环</span></span><br><span class="line">  <span class="keyword">while</span> (!contextp-&gt;<span class="built_in">gotFinish</span>()) {</span><br><span class="line">    <span class="type">int</span> a = <span class="built_in">rand</span>() &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="built_in">rand</span>() &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 对top module的input进行复制</span></span><br><span class="line">    top-&gt;a = a;</span><br><span class="line">    top-&gt;b = b;</span><br><span class="line">    <span class="comment">// 更新output</span></span><br><span class="line">    top-&gt;<span class="built_in">eval</span>(); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d, b = %d, f = %d\n"</span>, a, b, top-&gt;f);</span><br><span class="line">    <span class="built_in">assert</span>(top-&gt;f == (a ^ b));</span><br><span class="line">    <span class="comment">// 写入wave.vcd</span></span><br><span class="line">    tfp-&gt;<span class="built_in">dump</span>(contextp-&gt;<span class="built_in">time</span>());</span><br><span class="line">    <span class="comment">// 增加上下文的时间</span></span><br><span class="line">    contextp-&gt;<span class="built_in">timeInc</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (contextp-&gt;<span class="built_in">time</span>() &gt; <span class="number">3</span>) {</span><br><span class="line">      contextp-&gt;<span class="built_in">gotFinish</span>(<span class="literal">true</span>); <span class="comment">//当上下文的时间超过3时标记完成</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 释放heap上面的对象</span></span><br><span class="line">  <span class="keyword">delete</span> top;</span><br><span class="line">  <span class="keyword">delete</span> contextp;</span><br><span class="line">  tfp-&gt;<span class="built_in">close</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>tips: 若要生成VCD文件</p><ol type="1"><li>打开上下文中的traceOn</li><li>将输入输出写进VCD对象中</li><li>通过VCD对象写入文件</li><li>编译时请加上<code>-trace</code></li></ol></body></html>]]></content>
      
      
      <categories>
          
          <category> 一生一芯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一生一芯 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识Verilator</title>
      <link href="/2025/11/07/%E5%88%9D%E8%AF%86Verilator/"/>
      <url>/2025/11/07/%E5%88%9D%E8%AF%86Verilator/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><html><head></head><body><h2 id="verilator的工作原理">Verilator的工作原理</h2><p><img src="/2025/11/07/%E5%88%9D%E8%AF%86Verilator/Verilator使用指南.png"></p><ul><li><p>我们需要使用 C++ 编写激励文件。显然，我们不能在 testbench中直接调用我们 .v 中的模块，所以我们要通过 Verilator 将其转化为 C++文件再进行调用，Verilator为我们提供了顶层模块输入/输出引脚的接口，使我们得以对顶层模块的输入信号赋值或读取其输出信号。</p></li><li><p>Verilator 会生成一个 Makefile 脚本，利用 GCC 等编译器将生成的 C++文件和我们编写的激励文件编译成成用于仿真的可执行文件。</p></li></ul><h2 id="verilator-files">Verilator Files</h2><p><a href="https://verilator.org/guide/latest/files.html#files-read-written">RTFM</a></p><h2 id="verilator-command">Verilator Command</h2><figure class="highlight bash"><figcaption><span>shell</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man verilator</span><br></pre></td></tr></tbody></table></figure><h3 id="verilation生成可供调用的-c-文件">verilation(生成可供调用的 C++文件)</h3><figure class="highlight bash"><figcaption><span>shell</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&nbsp;verilator --cc [--top &lt;top-name&gt;] VerilogSourcefile</span><br></pre></td></tr></tbody></table></figure><ul><li><code>--cc</code>:指定将 Verilog 转化为 C++ 代码</li><li><code>--top</code>:当有多个Verilog 源文件的时候需要指定顶层模块</li><li><code>-Wall</code>:打开Verilator所有的警告</li><li><code>--Mdir &lt;directory&gt;</code>: 更改outputfile的路径，默认路径是obj_dir</li></ul><h3 id="编写testbench">编写testbench</h3><p>示例（双控开关）</p><figure class="highlight verilog"><figcaption><span>top.v</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top(</span><br><span class="line">  <span class="keyword">input</span> a,</span><br><span class="line">  <span class="keyword">input</span> b,</span><br><span class="line">  <span class="keyword">output</span> f</span><br><span class="line">);</span><br><span class="line">  <span class="keyword">assign</span> f = a ^ b;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><figcaption><span>main.cpp</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="comment">// 包含顶层模块的头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Vtop.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"verilated.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>{</span><br><span class="line">  VerilatedContext* contextp = <span class="keyword">new</span> VerilatedContext; <span class="comment">// 创建一个上下文对象</span></span><br><span class="line">  contextp-&gt;<span class="built_in">commandArgs</span>(argc, argv); </span><br><span class="line">  Vtop* top = <span class="keyword">new</span> Vtop{contextp}; <span class="comment">// 在heap上构造一个对象 {}列表初始化</span></span><br><span class="line">  <span class="comment">// 若上下文标记未完成，则一直循环</span></span><br><span class="line">  <span class="keyword">while</span> (!contextp-&gt;<span class="built_in">gotFinish</span>()) {</span><br><span class="line">    <span class="type">int</span> a = <span class="built_in">rand</span>() &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="built_in">rand</span>() &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 对top module的input进行复制</span></span><br><span class="line">    top-&gt;a = a;</span><br><span class="line">    top-&gt;b = b;</span><br><span class="line">    <span class="comment">// 更新output</span></span><br><span class="line">    top-&gt;<span class="built_in">eval</span>(); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d, b = %d, f = %d\n"</span>, a, b, top-&gt;f);</span><br><span class="line">    <span class="built_in">assert</span>(top-&gt;f == (a ^ b));</span><br><span class="line">    <span class="comment">// 增加上下文的时间</span></span><br><span class="line">    contextp-&gt;<span class="built_in">timeInc</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (contextp-&gt;<span class="built_in">time</span>() &gt; <span class="number">3</span>) {</span><br><span class="line">      contextp-&gt;<span class="built_in">gotFinish</span>(<span class="literal">true</span>); <span class="comment">//当上下文的时间超过3时标记完成</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 释放heap上面的对象</span></span><br><span class="line">  <span class="keyword">delete</span> top;</span><br><span class="line">  <span class="keyword">delete</span> contextp;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="生成可执行文件并运行">生成可执行文件并运行</h3><figure class="highlight bash"><figcaption><span>shell</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&nbsp;verilator --cc -Wall [--top &lt;top-name&gt;] VerilogSourcefile -exe testbenchfile </span><br></pre></td></tr></tbody></table></figure><ul><li><code>-exe</code>:其实这步就是将testbenchfile加入到生成的Makefile中</li><li><code>-bulid</code>:构建可执行文件（自动执行Makefile），我们可以后面手动构建如果不加这个option</li></ul><p><img src="/2025/11/07/%E5%88%9D%E8%AF%86Verilator/exeoption.png"></p><h4 id="手动构建可执行文件">手动构建可执行文件</h4><figure class="highlight bash"><figcaption><span>shell</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -C obj_dir -f Vtop.mk Vtop</span><br></pre></td></tr></tbody></table></figure><ul><li><code>-C</code>: Change to directory dir before reading themakefiles or doing anything else.</li><li><code>-f</code>: Use file as a makefile</li></ul><p>最后的Vtop是make要构建的目标(Target)</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 一生一芯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一生一芯 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随记1</title>
      <link href="/2025/11/07/%E9%9A%8F%E8%AE%B01/"/>
      <url>/2025/11/07/%E9%9A%8F%E8%AE%B01/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><html><head></head><body><p>2025年11月7日晚</p><p>我常常想两年后的我会走上什么的路。考研上岸后读研究生？考研失败后找份工作？亦或者是二战？这样一看，考研对我来说是件很重要的事。</p><p>如果它对我很重要的话，为什么我现在就不开始准备呢？为什么还要浪费时间在做一生一芯上呢？我很纠结。学校课程的作业、家里的事、一生一芯、考研…花在这些事情上的时间往往不能平衡要有取舍。</p><p>现在支撑我做一生一芯的动力就是<strong>完成入学答辩</strong>了，毕竟也花了这么多时间在上面，也不知道是对还是错，希望以后的我不会对这个决定后悔吧！</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 随记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息论与编码2</title>
      <link href="/2025/11/07/%E4%BF%A1%E6%81%AF%E8%AE%BA%E4%B8%8E%E7%BC%96%E7%A0%812/"/>
      <url>/2025/11/07/%E4%BF%A1%E6%81%AF%E8%AE%BA%E4%B8%8E%E7%BC%96%E7%A0%812/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><html><head></head><body><h2 id="联合熵条件熵熵">联合熵、条件熵、熵</h2><p><span class="math display">\[ H(X, Y) = H(X) + H (Y|X)\]</span></p><p>proof:</p><p><span class="math display">\[\begin{aligned}H(X,Y)&amp;= -\sum_{x,y} p(x,y)\,\log p(x,y) \\&amp;= -\sum_{x,y} p(x,y)\,\log\!\big(p(x)\,p(y\mid x)\big) \\&amp;= -\sum_{x,y} p(x,y)\,\log p(x) \;-\; \sum_{x,y} p(x,y)\,\logp(y\mid x) \\&amp;= -\sum_{x} \Big(\sum_y p(x,y)\Big)\log p(x)   \;-\; \sum_x p(x)\sum_y p(y\mid x)\,\log p(y\mid x) \\&amp;= -\sum_x p(x)\log p(x)   \;+\; \sum_x p(x)\,\Big(-\sum_y p(y\mid x)\log p(y\mid x)\Big) \\&amp;= H(X) \;+\; \sum_x p(x)\,H(Y\mid X{=}x) \\&amp;= H(X)+H(Y\mid X).\end{aligned}\]</span></p><h2 id="记忆信源与无记忆信源">记忆信源与无记忆信源</h2><ul><li><p>记忆信源：符号出现的概率与之前出现过的符号有关</p></li><li><p>无记忆信源：符号出现的概率与之前出现过符号的概率无关，只由符号自身的概率决定</p></li></ul><p>tips: 离散信源的输出是一个符号表{x1, x2, x3…}</p><h2 id="二重信源">二重信源</h2><p>def: 把原信源连续的两个符号当成一个新符号来看的那个新信源</p><h2 id="马尔科夫信源">马尔科夫信源</h2><p>def: 即有记忆的离散信源</p><p>k阶马尔科夫信源：当前输出符号与前k个符号有关</p><h3 id="状态转移">状态转移</h3><p>类似于FSM（有限状态机）。 <a href="https://zh.wikipedia.org/wiki/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA">wikiabout FSM</a></p><h3 id="马尔科夫信源熵">马尔科夫信源熵</h3><ul><li><p>从一个状态到另一个状态发生转移并发出一个符号的熵</p></li><li><p>信源平均输出一个符号的熵（每个状态的熵的均值）</p></li></ul><h3 id="冗余度">冗余度</h3><p>def: <span class="math display">\[ R = 1 -\frac{H(x)}{H_{max}}\]</span></p><p>这里的 <span class="math inline">\(\frac{H(x)}{H_{max}}\)</span>也叫信源效率</p><p>该值越大说明符号之间的相关性越强，</p><h3 id="时间熵">时间熵</h3><p>def：平均每秒传递的信息量 (bit/s)</p><p>formular：</p><p><span class="math display">\[H_t = H(X) / E(T)\]</span></p><p>其中<span class="math inline">\(E(T)\)</span>为发送一个符号的平均时间，<span class="math inline">\(H(X)\)</span>为信源熵即一个符号带有的信息量</p><h2 id="编码">编码</h2><p>def: 为信源发出的每个符号进行编码</p><h3 id="香农编码">香农编码</h3><p>如何进行香农编码: <img src="/2025/11/07/%E4%BF%A1%E6%81%AF%E8%AE%BA%E4%B8%8E%E7%BC%96%E7%A0%812/香农编码.png" width="500"></p><h3 id="哈夫曼编码">哈夫曼编码</h3><p>如何进行哈夫曼编码: <a href="https://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81#:~:text=Fig.1%E3%80%82-,%E6%BC%94%E7%AE%97%E8%BF%87%E7%A8%8B,-%5B%E7%BC%96%E8%BE%91%5D">wikiabout Huffman</a></p><h3 id="编码速率和编码效率">编码速率和编码效率</h3><p>def: 编码速率即平均码长（bit/符号）</p><p><span class="math display">\[\bar L = \sum_{i=1}^{\infty}p_i\,l_i\]</span></p><p>def: 编码效率即信源熵/平均码长</p><p><span class="math display">\[\eta = \frac{H(X)}{\bar{L}}\]</span></p><p>重要关系</p><ul><li><span class="math inline">\(H(X) \leq \bar L\)</span></li></ul><p>即信源熵是平均码长的下界，信源熵是一个信源发出一个符号带来的<strong>平均不确定度/信息量（需要多少bit去表示这个符号的发生）</strong>，而平均码长就是该编码表示一个符号的平均bits，当二者越接近说明这种编码方式的效率越高.</p><h2 id="离散信道容量">离散信道容量</h2><p>Reveiw:</p><p><code>互信息(Mutual Information)</code>:是一个衡量“知道一个变量能减少另一个变量多少不确定性”的量，或者说二者<strong><em>共享的信息量</em></strong>。</p><p>数学定义为:<span class="math inline">\(I(X;Y) = H(X) -H(X|Y)\)</span></p><h3 id="信道容量">信道容量</h3><table><colgroup><col style="width: 22%"><col style="width: 44%"><col style="width: 33%"></colgroup><thead><tr><th>目标</th><th>量</th><th>意义</th></tr></thead><tbody><tr><td>想看输出反映输入多少</td><td><span class="math inline">\(I(X;Y)\)</span></td><td>输入输出共享信息量</td></tr><tr><td>想找信道能力上限</td><td><span class="math inline">\(\max_{p(x)} I(X;Y)\)</span></td><td>最优输入分布下的最大共享信息量</td></tr></tbody></table><p>数学定义:</p><p><span class="math display">\[C =\max_{p(x)} I(X;Y)\]</span></p><p>当信道矩阵(转移概率矩阵)对称时有:</p><p><span class="math display">\[C = log_{2}M - H(Y|X)\]</span></p><h3 id="理想观测器">理想观测器</h3><p>什么是理想观测器(摘自ChatGPT5) <img src="/2025/11/07/%E4%BF%A1%E6%81%AF%E8%AE%BA%E4%B8%8E%E7%BC%96%E7%A0%812/理想观测器.png"></p><p>即根据条件概率选择当观测到某个y时，它的输入为x。</p><h3 id="误判概率">误判概率</h3><p>设计的理想观测器的误判概率</p><h2 id="question">Question</h2><ol type="1"><li>几何级数和几何级数求导求和？</li></ol></body></html>]]></content>
      
      
      <categories>
          
          <category> 本科课程 </category>
          
          <category> 信息论与编码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息论与编码 </tag>
            
            <tag> 本科课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.1 Orthogonality of the four subspaces</title>
      <link href="/2025/11/07/4-1-Orthogonality-of-the-four-subspaces/"/>
      <url>/2025/11/07/4-1-Orthogonality-of-the-four-subspaces/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><html><head></head><body><h2 id="总结">总结</h2><p><img src="/2025/11/07/4-1-Orthogonality-of-the-four-subspaces/conclusion.png"></p><p>对于这些内容接下来会一一解释</p><h2 id="向量之间的正交">向量之间的正交</h2><p><img src="/2025/11/07/4-1-Orthogonality-of-the-four-subspaces/vectors.png"></p><h2 id="空间之间的正交">空间之间的正交</h2><p>Def:两个空间相互正交，即在这两个空间中，分别取任意一个向量，这两个向量都正交</p><p>Ex: <img src="/2025/11/07/4-1-Orthogonality-of-the-four-subspaces/不正交的两个空间.png" width="200"></p><h3 id="正交补空间">正交补空间</h3><p>直观上：子空间<span class="math inline">\(U\)</span>和正交补空间<span class="math inline">\(U^{\perp}\)</span>的和构成了整个空间，即该空间中的一个向量可以分解为<span class="math inline">\(U\)</span>中的一个向量加上<span class="math inline">\(U^\perp\)</span>中的一个向量。</p><p>若<span class="math inline">\(U\)</span>和<span class="math inline">\(U\perp\)</span>都为<span class="math inline">\(R^n\)</span>的子空间，则有以下性质</p><ol type="1"><li><span class="math inline">\(dimU + dimU^\perp = n\)</span></li></ol><h2 id="四个子空间之间的关系">四个子空间之间的关系</h2><p><img src="/2025/11/07/4-1-Orthogonality-of-the-four-subspaces/四个子空间之间的关系.png"></p><ol type="1"><li>列空间和左零空间相互正交</li><li>行空间和零空间相互正交</li><li>方程<span class="math inline">\(Ax=b\)</span>中的x位于<span class="math inline">\(R^n\)</span>空间中</li><li>若矩阵A可逆，行空间中的所有向量与列空间中的向量一一对应</li></ol><h3 id="第二点的证明如下">第二点的证明如下:</h3><p><img src="/2025/11/07/4-1-Orthogonality-of-the-four-subspaces/行空间与零空间正交补.png"></p><ol type="1"><li>每一行与零空间的向量的点乘都为0</li><li>每个行向量之间的线性组合与零空间的点乘也为0 -&gt;线性组合构成行空间中的任意一个向量</li></ol><p>除此之外可以用代数的方法证明：</p><p><span class="math display">\[x^T(A^T y) = (Ax)^T y = 0\]</span></p><h3 id="第三第四点证明如下">第三第四点证明如下:</h3><p>第三点很显然，因为x有n个分量，肯定在<span class="math inline">\(R^n\)</span>中，根据正交补空间的性质，x就可以分解为<span class="math inline">\(x = x_{row} + x_{null}\)</span></p><p>故 <span class="math display">\[Ax = A(x_{row} + x_{null}) = Ax_{row}+ 0\]</span></p><p>当矩阵A不可逆的时候是做不到列空间中的向量与行空间中的向量一一对应的，因为存在着零空间的分量。但是当可逆的时候，零空间只有0。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>helloworld</title>
      <link href="/2025/11/06/helloworld/"/>
      <url>/2025/11/06/helloworld/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><html><head></head><body><p>Hello world!</p></body></html>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
