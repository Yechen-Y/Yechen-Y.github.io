<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>初识Verilator</title>
      <link href="/2025/11/07/%E5%88%9D%E8%AF%86Verilator/"/>
      <url>/2025/11/07/%E5%88%9D%E8%AF%86Verilator/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><html><head></head><body><h2 id="verilator的工作原理">Verilator的工作原理</h2><p><img src="/2025/11/07/%E5%88%9D%E8%AF%86Verilator/Verilator使用指南.png"></p><ul><li><p>我们需要使用 C++ 编写激励文件。显然，我们不能在 testbench中直接调用我们 .v 中的模块，所以我们要通过 Verilator 将其转化为 C++文件再进行调用，Verilator为我们提供了顶层模块输入/输出引脚的接口，使我们得以对顶层模块的输入信号赋值或读取其输出信号。</p></li><li><p>Verilator 会生成一个 Makefile 脚本，利用 GCC 等编译器将生成的 C++文件和我们编写的激励文件编译成成用于仿真的可执行文件。</p></li></ul><h2 id="verilator-files">Verilator Files</h2><p><a href="https://verilator.org/guide/latest/files.html#files-read-written">RTFM</a></p><h2 id="verilator-command">Verilator Command</h2><figure class="highlight bash"><figcaption><span>shell</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man verilator</span><br></pre></td></tr></tbody></table></figure><h3 id="verilation生成可供调用的-c-文件">verilation(生成可供调用的 C++文件)</h3><figure class="highlight bash"><figcaption><span>shell</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&nbsp;verilator --cc [--top &lt;top-name&gt;] VerilogSourcefile</span><br></pre></td></tr></tbody></table></figure><ul><li><code>--cc</code>:指定将 Verilog 转化为 C++ 代码</li><li><code>--top</code>:当有多个Verilog 源文件的时候需要指定顶层模块</li><li><code>-Wall</code>:打开Verilator所有的警告</li><li><code>--Mdir &lt;directory&gt;</code>: 更改outputfile的路径，默认路径是obj_dir</li></ul><h3 id="编写testbench">编写testbench</h3><p>示例（双控开关）</p><figure class="highlight verilog"><figcaption><span>top.v</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top(</span><br><span class="line">  <span class="keyword">input</span> a,</span><br><span class="line">  <span class="keyword">input</span> b,</span><br><span class="line">  <span class="keyword">output</span> f</span><br><span class="line">);</span><br><span class="line">  <span class="keyword">assign</span> f = a ^ b;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><figcaption><span>main.cpp</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="comment">// 包含顶层模块的头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Vtop.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"verilated.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>{</span><br><span class="line">  VerilatedContext* contextp = <span class="keyword">new</span> VerilatedContext; <span class="comment">// 创建一个上下文对象</span></span><br><span class="line">  contextp-&gt;<span class="built_in">commandArgs</span>(argc, argv); </span><br><span class="line">  Vtop* top = <span class="keyword">new</span> Vtop{contextp}; <span class="comment">// 在heap上构造一个对象 {}列表初始化</span></span><br><span class="line">  <span class="comment">// 若上下文标记未完成，则一直循环</span></span><br><span class="line">  <span class="keyword">while</span> (!contextp-&gt;<span class="built_in">gotFinish</span>()) {</span><br><span class="line">    <span class="type">int</span> a = <span class="built_in">rand</span>() &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="built_in">rand</span>() &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 对top module的input进行复制</span></span><br><span class="line">    top-&gt;a = a;</span><br><span class="line">    top-&gt;b = b;</span><br><span class="line">    <span class="comment">// 更新output</span></span><br><span class="line">    top-&gt;<span class="built_in">eval</span>(); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d, b = %d, f = %d\n"</span>, a, b, top-&gt;f);</span><br><span class="line">    <span class="built_in">assert</span>(top-&gt;f == (a ^ b));</span><br><span class="line">    <span class="comment">// 增加上下文的时间</span></span><br><span class="line">    contextp-&gt;<span class="built_in">timeInc</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (contextp-&gt;<span class="built_in">time</span>() &gt; <span class="number">3</span>) {</span><br><span class="line">      contextp-&gt;<span class="built_in">gotFinish</span>(<span class="literal">true</span>); <span class="comment">//当上下文的时间超过3时标记完成</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 释放heap上面的对象</span></span><br><span class="line">  <span class="keyword">delete</span> top;</span><br><span class="line">  <span class="keyword">delete</span> contextp;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="生成可执行文件并运行">生成可执行文件并运行</h3><figure class="highlight bash"><figcaption><span>shell</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&nbsp;verilator --cc -Wall [--top &lt;top-name&gt;] VerilogSourcefile -exe testbenchfile </span><br></pre></td></tr></tbody></table></figure><ul><li><code>-exe</code>:其实这步就是将testbenchfile加入到生成的Makefile中</li><li><code>-bulid</code>:构建可执行文件（自动执行Makefile），我们可以后面手动构建如果不加这个option</li></ul><p><img src="/2025/11/07/%E5%88%9D%E8%AF%86Verilator/exeoption.png"></p><h4 id="手动构建可执行文件">手动构建可执行文件</h4><figure class="highlight bash"><figcaption><span>shell</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -C obj_dir -f Vtop.mk Vtop</span><br></pre></td></tr></tbody></table></figure><ul><li><code>-C</code>: Change to directory dir before reading themakefiles or doing anything else.</li><li><code>-f</code>: Use file as a makefile</li></ul><p>最后的Vtop是make要构建的目标(Target)</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 一生一芯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一生一芯 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随记1</title>
      <link href="/2025/11/07/%E9%9A%8F%E8%AE%B01/"/>
      <url>/2025/11/07/%E9%9A%8F%E8%AE%B01/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><html><head></head><body><p>2025年11月7日晚</p><p>我常常想两年后的我会走上什么的路。考研上岸后读研究生？考研失败后找份工作？亦或者是二战？这样一看，考研对我来说是件很重要的事。</p><p>如果它对我很重要的话，为什么我现在就不开始准备呢？为什么还要浪费时间在做一生一芯上呢？我很纠结。学校课程的作业、家里的事、一生一芯、考研…花在这些事情上的时间往往不能平衡要有取舍。</p><p>现在支撑我做一生一芯的动力就是<strong>完成入学答辩</strong>了，毕竟也花了这么多时间在上面，也不知道是对还是错，希望以后的我不会对这个决定后悔吧！</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 随记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息论与编码2</title>
      <link href="/2025/11/07/%E4%BF%A1%E6%81%AF%E8%AE%BA%E4%B8%8E%E7%BC%96%E7%A0%812/"/>
      <url>/2025/11/07/%E4%BF%A1%E6%81%AF%E8%AE%BA%E4%B8%8E%E7%BC%96%E7%A0%812/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><html><head></head><body><h2 id="联合熵条件熵熵">联合熵、条件熵、熵</h2><p><span class="math display">\[ H(X, Y) = H(X) + H (Y|X)\]</span></p><p>proof:</p><p><span class="math display">\[\begin{aligned}H(X,Y)&amp;= -\sum_{x,y} p(x,y)\,\log p(x,y) \\&amp;= -\sum_{x,y} p(x,y)\,\log\!\big(p(x)\,p(y\mid x)\big) \\&amp;= -\sum_{x,y} p(x,y)\,\log p(x) \;-\; \sum_{x,y} p(x,y)\,\logp(y\mid x) \\&amp;= -\sum_{x} \Big(\sum_y p(x,y)\Big)\log p(x)   \;-\; \sum_x p(x)\sum_y p(y\mid x)\,\log p(y\mid x) \\&amp;= -\sum_x p(x)\log p(x)   \;+\; \sum_x p(x)\,\Big(-\sum_y p(y\mid x)\log p(y\mid x)\Big) \\&amp;= H(X) \;+\; \sum_x p(x)\,H(Y\mid X{=}x) \\&amp;= H(X)+H(Y\mid X).\end{aligned}\]</span></p><h2 id="记忆信源与无记忆信源">记忆信源与无记忆信源</h2><ul><li><p>记忆信源：符号出现的概率与之前出现过的符号有关</p></li><li><p>无记忆信源：符号出现的概率与之前出现过符号的概率无关，只由符号自身的概率决定</p></li></ul><p>tips: 离散信源的输出是一个符号表{x1, x2, x3…}</p><h2 id="二重信源">二重信源</h2><p>def: 把原信源连续的两个符号当成一个新符号来看的那个新信源</p><h2 id="马尔科夫信源">马尔科夫信源</h2><p>def: 即有记忆的离散信源</p><p>k阶马尔科夫信源：当前输出符号与前k个符号有关</p><h3 id="状态转移">状态转移</h3><p>类似于FSM（有限状态机）。 <a href="https://zh.wikipedia.org/wiki/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA">wikiabout FSM</a></p><h3 id="马尔科夫信源熵">马尔科夫信源熵</h3><ul><li><p>从一个状态到另一个状态发生转移并发出一个符号的熵</p></li><li><p>信源平均输出一个符号的熵（每个状态的熵的均值）</p></li></ul><h3 id="冗余度">冗余度</h3><p>def: <span class="math display">\[ R = 1 -\frac{H(x)}{H_{max}}\]</span></p><p>这里的 <span class="math inline">\(\frac{H(x)}{H_{max}}\)</span>也叫信源效率</p><p>该值越大说明符号之间的相关性越强，</p><h3 id="时间熵">时间熵</h3><p>def：平均每秒传递的信息量 (bit/s)</p><p>formular：</p><p><span class="math display">\[H_t = H(X) / E(T)\]</span></p><p>其中<span class="math inline">\(E(T)\)</span>为发送一个符号的平均时间，<span class="math inline">\(H(X)\)</span>为信源熵即一个符号带有的信息量</p><h2 id="编码">编码</h2><p>def: 为信源发出的每个符号进行编码</p><h3 id="香农编码">香农编码</h3><p>如何进行香农编码: <img src="/2025/11/07/%E4%BF%A1%E6%81%AF%E8%AE%BA%E4%B8%8E%E7%BC%96%E7%A0%812/香农编码.png" width="500"></p><h3 id="哈夫曼编码">哈夫曼编码</h3><p>如何进行哈夫曼编码: <a href="https://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81#:~:text=Fig.1%E3%80%82-,%E6%BC%94%E7%AE%97%E8%BF%87%E7%A8%8B,-%5B%E7%BC%96%E8%BE%91%5D">wikiabout Huffman</a></p><h3 id="编码速率和编码效率">编码速率和编码效率</h3><p>def: 编码速率即平均码长（bit/符号）</p><p><span class="math display">\[\bar L = \sum_{i=1}^{\infty}p_i\,l_i\]</span></p><p>def: 编码效率即信源熵/平均码长</p><p><span class="math display">\[\eta = \frac{H(X)}{\bar{L}}\]</span></p><p>重要关系</p><ul><li><span class="math inline">\(H(X) \leq \bar L\)</span></li></ul><p>即信源熵是平均码长的下界，信源熵是一个信源发出一个符号带来的<strong>平均不确定度/信息量（需要多少bit去表示这个符号的发生）</strong>，而平均码长就是该编码表示一个符号的平均bits，当二者越接近说明这种编码方式的效率越高.</p><h2 id="question">Question</h2><ol type="1"><li>几何级数和几何级数求导求和？</li></ol></body></html>]]></content>
      
      
      <categories>
          
          <category> 本科课程 </category>
          
          <category> 信息论与编码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息论与编码 </tag>
            
            <tag> 本科课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.1 Orthogonality of the four subspaces</title>
      <link href="/2025/11/07/4-1-Orthogonality-of-the-four-subspaces/"/>
      <url>/2025/11/07/4-1-Orthogonality-of-the-four-subspaces/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><html><head></head><body><h2 id="总结">总结</h2><p><img src="/2025/11/07/4-1-Orthogonality-of-the-four-subspaces/conclusion.png"></p><p>对于这些内容接下来会一一解释</p><h2 id="向量之间的正交">向量之间的正交</h2><p><img src="/2025/11/07/4-1-Orthogonality-of-the-four-subspaces/vectors.png"></p><h2 id="空间之间的正交">空间之间的正交</h2><p>Def:两个空间相互正交，即在这两个空间中，分别取任意一个向量，这两个向量都正交</p><p>Ex: <img src="/2025/11/07/4-1-Orthogonality-of-the-four-subspaces/不正交的两个空间.png" width="200"></p><h3 id="正交补空间">正交补空间</h3><p>直观上：子空间<span class="math inline">\(U\)</span>和正交补空间<span class="math inline">\(U^{\perp}\)</span>的和构成了整个空间，即该空间中的一个向量可以分解为<span class="math inline">\(U\)</span>中的一个向量加上<span class="math inline">\(U^\perp\)</span>中的一个向量。</p><p>若<span class="math inline">\(U\)</span>和<span class="math inline">\(U\perp\)</span>都为<span class="math inline">\(R^n\)</span>的子空间，则有以下性质</p><ol type="1"><li><span class="math inline">\(dimU + dimU^\perp = n\)</span></li></ol><h2 id="四个子空间之间的关系">四个子空间之间的关系</h2><p><img src="/2025/11/07/4-1-Orthogonality-of-the-four-subspaces/四个子空间之间的关系.png"></p><ol type="1"><li>列空间和左零空间相互正交</li><li>行空间和零空间相互正交</li><li>方程<span class="math inline">\(Ax=b\)</span>中的x位于<span class="math inline">\(R^n\)</span>空间中</li><li>若矩阵A可逆，行空间中的所有向量与列空间中的向量一一对应</li></ol><h3 id="第二点的证明如下">第二点的证明如下:</h3><p><img src="/2025/11/07/4-1-Orthogonality-of-the-four-subspaces/行空间与零空间正交补.png"></p><ol type="1"><li>每一行与零空间的向量的点乘都为0</li><li>每个行向量之间的线性组合与零空间的点乘也为0 -&gt;线性组合构成行空间中的任意一个向量</li></ol><p>除此之外可以用代数的方法证明：</p><p><span class="math display">\[x^T(A^T y) = (Ax)^T y = 0\]</span></p><h3 id="第三第四点证明如下">第三第四点证明如下:</h3><p>第三点很显然，因为x有n个分量，肯定在<span class="math inline">\(R^n\)</span>中，根据正交补空间的性质，x就可以分解为<span class="math inline">\(x = x_{row} + x_{null}\)</span></p><p>故 <span class="math display">\[Ax = A(x_{row} + x_{null}) = Ax_{row}+ 0\]</span></p><p>当矩阵A不可逆的时候是做不到列空间中的向量与行空间中的向量一一对应的，因为存在着零空间的分量。但是当可逆的时候，零空间只有0。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>helloworld</title>
      <link href="/2025/11/06/helloworld/"/>
      <url>/2025/11/06/helloworld/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><html><head></head><body><p>Hello world!</p></body></html>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
