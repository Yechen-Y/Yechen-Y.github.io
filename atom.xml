<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yechen&#39;s Blog</title>
  
  <subtitle>随便写写</subtitle>
  <link href="https://www.yechenblog.top/atom.xml" rel="self"/>
  
  <link href="https://www.yechenblog.top/"/>
  <updated>2025-11-23T15:33:39.607Z</updated>
  <id>https://www.yechenblog.top/</id>
  
  <author>
    <name>Yechen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>信息的表示和处理</title>
    <link href="https://www.yechenblog.top/2025/11/19/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/"/>
    <id>https://www.yechenblog.top/2025/11/19/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/</id>
    <published>2025-11-19T14:50:32.000Z</published>
    <updated>2025-11-23T15:33:39.607Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><html><head></head><body><h1 id="码制">码制</h1><p>不同的 <code>码制</code> 即对 <code>位模式</code>做出不同的解释。</p><table><thead><tr><th style="text-align: center;">原码</th><th style="text-align: center;">反码</th><th style="text-align: center;">补码</th></tr></thead><tbody><tr><td style="text-align: center;">最高位作为符号位</td><td style="text-align: center;"><span class="math inline">\(-2^{w - 1} -1\)</span></td><td style="text-align: center;"><span class="math inline">\(-2^w\)</span></td></tr><tr><td style="text-align: center;">符号位取反</td><td style="text-align: center;">$2^w - 1 - x $</td><td style="text-align: center;">$2^w - x $</td></tr></tbody></table><p>第二行是不同码制对最高位的解释，第三行是已知 <code>x</code> 如何求<code>-x</code> 的表示</p><h2 id="原码">原码</h2><p>为了区分正数和负数，用最高位当作符号位。这样符合人类的直觉，但对计算机计算很不友好。比如:</p><p>计算 <span class="math inline">\(1 + (-1)\)</span></p><ul><li>原码表示 <code>0001</code> + <code>1001</code></li><li>如果是纯加法电路会得到 <code>0001</code> + <code>1001</code> =<code>1010</code> (结果为-2)，计算有误。</li></ul><p>这意味着，如果用原码来表示数字，CPU的计算单元(ALU)必须设计的十分复杂。他必须先判断符号位:</p><ol type="1"><li>如果符号相同做加法</li><li>如果符号不相同，比较绝对值的大小，用大的减小的，最后决定结果的符号。</li></ol><p>为了解决这一问题，就有了反码</p><h2 id="反码">反码</h2><p>要了解反码，就要了解反码是怎么来的</p><h3 id="反码的来源">反码的来源</h3><blockquote><p>早在机械计算器时代（比如 17世纪帕斯卡的加法机），人们就在思考：“怎样把该死的减法变成加法？”因为制造一个能倒着转、能处理“借位”的齿轮装置，比制造一个只管顺着转、只管“进位”的装置要复杂得多。</p></blockquote><p>比如有个只能处理 <code>0~99</code> 的机器，我们要计算<code>56 - 13</code>，但是我们不想让其倒着转(减法)，我们可以通过让<code>56</code> 加上 <code>13</code> 的反码<code>99 - 13 = 86</code>，让机器一直顺着转(加法)，即可。最后得到的结果为<span class="math display">\[ 56 + 86 = 142\]</span></p><p>与正确结果有误差，我们只用把进位 <code>1</code> 加上即可<code>42 + 1 = 43</code></p><h3 id="二进制中的反码">二进制中的反码</h3><p>根据上述的故事，我们就可以定义反码了:</p><p><span class="math display">\[-x_反 = 2^w - 1 - x_反\]</span> 即用<code>11111...11</code> -<code>x</code>，这在电路中非常容易实现，只需用一个<code>反相器(NOT GATE)</code> 即可。</p><p>根据这个定义，我们就可以推导出最高位的数值为 <span class="math inline">\(2^{w-1} - 1\)</span></p><h4 id="处理溢出">处理溢出</h4><p>计算 <span class="math inline">\(A - B\)</span></p><ol type="1"><li><p>A &gt; B <span class="math display">\[\begin{aligned}A + (2^w - 1 - B) &amp;= 2^w + (A - B - 1) \\&amp;= A - B - 1\end{aligned}\]</span> 最后得到的结果比实际的结果少1</p></li><li><p>A &lt; B <span class="math display">\[\begin{aligned}A + (2^w - 1 - B) &amp;= 2^w - 1 - (B - A)\end{aligned}\]</span>最后得到<code>B - A</code>的反码表示，与结果符合(因为<code>B - A</code>的反码的值就是<code>-(B - A)</code>= <code>A - B</code>)</p></li></ol><h2 id="补码">补码</h2><p>为了解决反码中溢出的问题，我们定义:</p><p><span class="math display">\[ -x_补 = 2^w - x_补\]</span></p><p>通过该定义也可以推导出，补码最高位的数值为<span class="math inline">\(-2^{w-1}\)</span></p><h3 id="补码与反码的关系">补码与反码的关系</h3><p><span class="math display">\[ -x_补 = -x_反 + 1 \]</span></p><p>推导如下:</p><p><span class="math display">\[\begin{aligned}-x_补 &amp;= 2^w - x_补 \\&amp;= (2^w - 1 - x_补) + 1 \\&amp;= -x_反 + 1\end{aligned}\]</span></p><h1 id="有符号和无符号之间的转化">有符号和无符号之间的转化</h1><p>设 <code>x</code> 为一个位向量，其位模式可以表示为 <span class="math inline">\([x_{w - 1}, x_{w - 2}, x_{w - 3} ... ,x_0]\)</span></p><p>定义如下函数:</p><p><code>B2U(x)</code> = <span class="math inline">\(\sum_{i=0}^{w-1}2^{i}x_i\)</span></p><p><code>B2T(x)</code> = <span class="math inline">\(-x_{w-1}2^{w-1} +\sum_{i=0}^{w-2}2^{i}x_i\)</span></p><p>根据以上定义，我们可以得到同一个 <code>位模式</code>，不同的解释方式(补码或者无符号)得到的值有如下的关系:</p><p><span class="math display">\[\begin{aligned}B2U(x) - B2T(x) &amp;= x_{w-1}2^{w} \\B2T(x) &amp;= B2U(x) - x_{w-1}2^{w}\\\end{aligned}\]</span></p><h1 id="整数运算">整数运算</h1><h2 id="无符号加法和补码加法">无符号加法和补码加法</h2><p>计算中用同一个加法器去处理无符号加法和补码加法</p><p><code>x 和 y</code>: 都为位宽为 <code>w</code> 的位向量。</p><p><span class="math inline">\(x_{u}、y_{u}、x_{s}、y_{s}\)</span>为<code>x和y</code>的无符号和补码表示。</p><p>因为我们限制了结果只能用 <code>w</code>位表示，所以<strong><em>值上有</em></strong>如下关系:</p><p>无符号加法: <span class="math display">\[x_{u} + y_{u} = (x_{u} + y_{u})(mod\ 2^w)\]</span></p><p>补码加法: <span class="math display">\[\begin{aligned}x_{t} + y_{t} = U2T(x_{u} + y_{u})\end{aligned}\]</span></p><p>具体溢出等情况可以参考CSAPP中的内容(P60)</p></body></html>]]></content>
    
    
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;码制
不同的 码制 即对 位模式做出不同的解释。

原码反码补码最高位作为符号位&#92;(-2^{w - 1} - 1&#92;)&#92;(-2^w&#92;)符号位取反$2^w - 1 - x $$2^w - x $第二行是不同码制对最高位的解释，第三行是已知 x 如何求-x 的表示

原码
为了区分正数和负数，用最高位当作符号位。这样符合人类的直觉，但对计算机计算很不友好。比如:

计算 &#92;(1 + (-1)&#92;)

 * 原码表示 0001 + 1001
 * 如果是纯加法电路会得到 0001 + 1001 =1010 (结果为-2)，计算有误。

这意味着，如果用原码来表示数字，CPU的计算单元(ALU)必须设计的&lt;/body&gt;&lt;/html&gt;</summary>
    
    
    
    <category term="计组" scheme="https://www.yechenblog.top/categories/%E8%AE%A1%E7%BB%84/"/>
    
    
    <category term="计组" scheme="https://www.yechenblog.top/tags/%E8%AE%A1%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>从c语言到二进制代码</title>
    <link href="https://www.yechenblog.top/2025/11/19/%E4%BB%8Ec%E8%AF%AD%E8%A8%80%E5%88%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BB%A3%E7%A0%81/"/>
    <id>https://www.yechenblog.top/2025/11/19/%E4%BB%8Ec%E8%AF%AD%E8%A8%80%E5%88%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BB%A3%E7%A0%81/</id>
    <published>2025-11-19T02:53:05.000Z</published>
    <updated>2025-11-19T02:56:14.576Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><html><head></head><body><p>从c语言到二进制代码可分为</p><p><code>预处理</code> -&gt; <code>编译</code> -&gt; <code>汇编</code>-&gt; <code>链接</code> 这四个过程</p><h2 id="预处理">预处理</h2></body></html>]]></content>
    
    
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;从c语言到二进制代码可分为

预处理 -&amp;gt; 编译 -&amp;gt; 汇编-&amp;gt; 链接 这四个过程

预处理&lt;/body&gt;&lt;/html&gt;</summary>
    
    
    
    <category term="一生一芯" scheme="https://www.yechenblog.top/categories/%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF/"/>
    
    
    <category term="一生一芯" scheme="https://www.yechenblog.top/tags/%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF/"/>
    
  </entry>
  
  <entry>
    <title>随记3</title>
    <link href="https://www.yechenblog.top/2025/11/18/%E9%9A%8F%E8%AE%B03/"/>
    <id>https://www.yechenblog.top/2025/11/18/%E9%9A%8F%E8%AE%B03/</id>
    <published>2025-11-18T02:39:48.000Z</published>
    <updated>2025-11-18T02:46:13.249Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><html><head></head><body><p>我是个很幸运的人，在这21年中我受到了来自很多人的帮助和关爱。即使我也受到了很多挫折，但是幸运的是我没被打倒。</p><p>最近几年发生了很多事，可以说是彻底改变了我。我的女朋友给予了我很大帮助，我非常非常感谢她，也觉得非常幸运能遇到她。</p></body></html>]]></content>
    
    
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;我是个很幸运的人，在这21年中我受到了来自很多人的帮助和关爱。即使我也受到了很多挫折，但是幸运的是我没被打倒。

最近几年发生了很多事，可以说是彻底改变了我。我的女朋友给予了我很大帮助，我非常非常感谢她，也觉得非常幸运能遇到她。&lt;/body&gt;&lt;/html&gt;</summary>
    
    
    
    <category term="随记" scheme="https://www.yechenblog.top/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
    <category term="随记" scheme="https://www.yechenblog.top/tags/%E9%9A%8F%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>接入NVBoard</title>
    <link href="https://www.yechenblog.top/2025/11/12/%E6%8E%A5%E5%85%A5NVBoard/"/>
    <id>https://www.yechenblog.top/2025/11/12/%E6%8E%A5%E5%85%A5NVBoard/</id>
    <published>2025-11-12T08:50:52.000Z</published>
    <updated>2025-11-13T15:40:50.381Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><html><head></head><body><h2 id="makefile">Makefile</h2><p>为了搞懂NVBoard是怎么工作的，先看一下它的构建规则是怎么样的</p><p>其构建规则在<code>/scripts/nvboard.mk</code>中，Makefile的一些补充知识</p><ol type="1"><li><p>自动变量:</p><p><code>$@</code>: 目标</p><p><code>$&lt;</code>: 第一个依赖</p><p><code>$^</code>: 所有依赖(去重)</p><p><code>$+</code>: 所有依赖(不去重)</p></li><li><p>命令前加<code>@</code>，不在终端中显示该命令，但仍会显示输出</p></li><li><p>内建变量:</p><p><code>CXX</code>: cpp编译器</p><p><code>CC</code>: c编译器</p><p><code>CPPFLAGS</code>: 编译器选项</p><p><code>CFLAGS</code></p></li><li><p>赋值</p><p><code>=</code>: 展开赋值(动态值),使用时才赋值</p><p><code>:=</code>: 立即赋值(静态值)</p><p><code>+=</code>: 追加赋值</p><p><code>?=</code>: 条件赋值，只有在没有被定义的时候才会赋值</p></li><li><p>同名目标的多个规则会合并</p></li><li><p>依赖中的变量会在读取Makefile时展开(编读边展开)，而规则中的变量会在使用时展开。而Makefile会读取完整个文件后再执行对应的规则</p></li><li><p>Makefile 默认的 target 是 file 中的第一个 target</p></li></ol><h2 id="接入nvboard流水灯">接入NVBoard(流水灯)</h2><h3 id="编写makefile">编写Makefile</h3><p>参考NVBoard/example中的Makefile，但有几点是要注意的</p><ol type="1"><li></li></ol></body></html>]]></content>
    
    
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;Makefile
为了搞懂NVBoard是怎么工作的，先看一下它的构建规则是怎么样的

其构建规则在/scripts/nvboard.mk中，Makefile的一些补充知识

 1. 自动变量:
    
    $@: 目标
    
    $&amp;lt;: 第一个依赖
    
    $^: 所有依赖(去重)
    
    $+: 所有依赖(不去重)
    
    
 2. 命令前加@，不在终端中显示该命令，但仍会显示输出
    
    
 3. 内建变量:
    
    CXX: cpp编译器
    
    CC: c编译器
    
    CPPFLAGS: 编译器选项&lt;/body&gt;&lt;/html&gt;</summary>
    
    
    
    <category term="一生一芯" scheme="https://www.yechenblog.top/categories/%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF/"/>
    
    
    <category term="一生一芯" scheme="https://www.yechenblog.top/tags/%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF/"/>
    
    <category term="Makefile" scheme="https://www.yechenblog.top/tags/Makefile/"/>
    
  </entry>
  
  <entry>
    <title>Projection Matrices and Least Squares</title>
    <link href="https://www.yechenblog.top/2025/11/12/Projection-Matrices-and-Least-Squares/"/>
    <id>https://www.yechenblog.top/2025/11/12/Projection-Matrices-and-Least-Squares/</id>
    <published>2025-11-12T08:03:59.000Z</published>
    <updated>2025-11-15T10:07:33.958Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><html><head></head><body><h1 id="投影projection">投影(Projection)</h1><h2 id="概要">概要</h2><p><img src="/2025/11/12/Projection-Matrices-and-Least-Squares/projectionConclusion.png"></p><h2 id="投影矩阵投影误差向量">投影矩阵、投影、误差向量</h2><p>目标: 找出向量b在空间S上的投影p，以及产生p的矩阵P</p><p>误差向量: <span class="math inline">\(e = b - p = A \hatx\)</span></p><p>tips: A 是空间 S 的基向量构成的矩阵</p><p>方法: 根据几何关系可以得到<span class="math inline">\(e\)</span>与空间S正交。描述一个空间的最好方法就是用<strong>基向量</strong>描述，<strong><em>把基向量放入矩阵A中，该矩阵的列空间即为空间S</em></strong>，由<span class="math inline">\(e \perp S\)</span>，得到<span class="math inline">\(e \inLN(S)\)</span>，即误差向量在S的左零空间中。</p><p>下图是图例: <img src="/2025/11/12/Projection-Matrices-and-Least-Squares/投影图例.png"></p><p>由上述关系可得:</p><p><span class="math display">\[\begin{aligned}A^\top (b - A\hat x) &amp;= 0 \\\hat x &amp;= (A^\top A)^{-1}A^\top b \\p &amp;= Ax = A(A^\top A)^{-1}A^\top b \\P &amp;= A(A^\top A)^{-1}A^\top\end{aligned}\]</span></p><h1 id="最小二乘法least-squares">最小二乘法(Least Squares)</h1><p>目的: <span class="math inline">\(Ax =b\)</span>有时候无解,我们为了找到最接近的(误差最小的解),可以去解<span class="math inline">\(A\hat x=p\)</span>,其中<span class="math inline">\(b = p + e\)</span></p><p><img src="/2025/11/12/Projection-Matrices-and-Least-Squares/最小二乘法图例.png" width="500"></p><p>上图是最直观的一幅图，有以下几点需要注意</p><ol type="1"><li>A是线性无关的列构成的矩阵，所以其零空间只有0</li><li>因为列空间和左零空间互为正交补空间，所以b能分解为<span class="math inline">\(p+e\)</span></li><li>将b投影到p的投影矩阵是P,而投影到e的投影矩阵是I-P</li></ol><p>第三点的证明:</p><p>我们已知<span class="math inline">\(b = p + e\)</span>,而<span class="math inline">\(p = Pb\)</span>,简单代数运算后得到<span class="math inline">\(e =(I-P)b\)</span>,然后再证明e在A的左零空间中.</p><p><span class="math display">\[\begin{aligned}P &amp;= A (A^T A)^{-1} A^T \\A^T P &amp;= A^T \bigl(A (A^T A)^{-1} A^T \bigr) \\&amp;= (A^T A)(A^T A)^{-1} A^T \\&amp;= A^T \\A^T(I-P) &amp;= A^T - A^T P = 0 \\A^T(I-P)\mathbf b &amp;= 0 \\\end{aligned}\]</span></p><p>另一个证明:</p><p><span class="math display">\[\begin{aligned}e &amp;= b - p \\Pe &amp; = P(b - p)\\&amp;= p - p \\&amp; = 0\end{aligned}\]</span> ## <span class="math inline">\(A^TA\)</span>的可逆性证明</p><p>前提条件: A的列向量是线性无关的</p><p>proof: 要证<span class="math inline">\(A^TA\)</span>可逆，即证<span class="math inline">\(A^TAx=0\)</span>的解只有零向量 <span class="math display">\[\begin{aligned}suppose:A^TAx &amp;= 0 \\x^TA^TAx &amp;=0 \\(Ax)^TAx &amp;=0 \\Ax = 0 \\\end{aligned}\]</span></p><p>最后得到只需要证明<span class="math inline">\(Ax=0\)</span>，但我们的前提条件是A的列向量之间是线性无关的，所以证毕</p><h2 id="补充">补充</h2><ol type="1"><li>若b在子空间S中，则<span class="math inline">\(Pb =b\)</span>。反之也成立。</li><li>若b垂直于子空间S，则<span class="math inline">\(Pb =0\)</span>。反之也成立。</li></ol><p>第一条证明:</p><p>因为b在子空间S中，所以b为列向量的线性组合，即<span class="math inline">\(b = Ax\)</span> <span class="math display">\[\begin{aligned}P &amp;= A(A^TA)^{-1}A^T \\Pb &amp;= A(A^TA)^{-1}A^Tb \\&amp;= A(A^TA)^{-1}A^TAx \\&amp;= A(A^TA)^{-1}(A^TA)x \\&amp;= Ax \\&amp;= b \\\end{aligned}\]</span></p><p>第二条证明:</p><p>因为b垂直于子空间S，则<span class="math inline">\(b \inS^\perp\)</span>，所以<span class="math inline">\(A^Tb = 0\)</span></p><p><span class="math display">\[\begin{aligned}P &amp;= A(A^TA)^{-1}A^T \\Pb &amp;= A(A^TA)^{-1}A^Tb \\&amp;= 0\end{aligned}\]</span></p></body></html>]]></content>
    
    
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;投影(Projection)
概要


投影矩阵、投影、误差向量
目标: 找出向量b在空间S上的投影p，以及产生p的矩阵P

误差向量: &#92;(e = b - p = A &#92;hat x&#92;)

tips: A 是空间 S 的基向量构成的矩阵

方法: 根据几何关系可以得到&#92;(e&#92;)与空间S正交。描述一个空间的最好方法就是用基向量描述，把基向量放入矩阵A中，该矩阵的列空间即为空间S，由&#92;(e &#92;perp S&#92;)，得到&#92;(e &#92;in LN(S)&#92;)，即误差向量在S的左零空间中。

下图是图例: 

由上述关系可得:

&#92;[ &#92;begin{aligned} A^&#92;top (b - A&#92;hat x) &amp;amp;=&lt;/body&gt;&lt;/html&gt;</summary>
    
    
    
    <category term="线性代数" scheme="https://www.yechenblog.top/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    
    <category term="线性代数" scheme="https://www.yechenblog.top/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    <category term="数学" scheme="https://www.yechenblog.top/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>随记2</title>
    <link href="https://www.yechenblog.top/2025/11/12/%E9%9A%8F%E8%AE%B02/"/>
    <id>https://www.yechenblog.top/2025/11/12/%E9%9A%8F%E8%AE%B02/</id>
    <published>2025-11-12T07:21:56.000Z</published>
    <updated>2025-11-12T07:23:33.305Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><html><head></head><body><p>路还很长，对自己不要太严格了，take it easy.</p></body></html>]]></content>
    
    
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;路还很长，对自己不要太严格了，take it easy.&lt;/body&gt;&lt;/html&gt;</summary>
    
    
    
    <category term="随记" scheme="https://www.yechenblog.top/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
    <category term="随记" scheme="https://www.yechenblog.top/tags/%E9%9A%8F%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>随机信号处理-功率谱</title>
    <link href="https://www.yechenblog.top/2025/11/12/%E9%9A%8F%E6%9C%BA%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86-%E5%8A%9F%E7%8E%87%E8%B0%B1/"/>
    <id>https://www.yechenblog.top/2025/11/12/%E9%9A%8F%E6%9C%BA%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86-%E5%8A%9F%E7%8E%87%E8%B0%B1/</id>
    <published>2025-11-12T02:26:26.000Z</published>
    <updated>2025-11-12T03:51:36.366Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><html><head></head><body><p>只为了考试！</p><h2 id="过程的一些数字特征">过程的一些数字特征</h2><ol type="1"><li>均值<ul><li>若功率谱连续则均值为0</li></ul></li><li>自相关函数和互相关函数<ul><li>自相关 <span class="math inline">\(R_{X}(\tau) =\mathbb{E}[X(t)X(t+\tau)]\)</span></li><li>互相关 <span class="math inline">\(R_{XY}(\tau) =\mathbb{E}[X(t)Y(t+\tau)]\)</span></li></ul></li><li>自相关系数<ul><li>def: <span class="math inline">\(\rho_X(\tau)=\frac{R_X(\tau)}{R_X(0)},\qquad\rho_X(0)=1\)</span></li></ul></li><li>方差/协方差<ul><li>方差计算公式: <span class="math inline">\(Var(X) = R_{X}(0) -m_{X}^2 = E[(X - E(X))^2]\)</span></li><li>协方差计算公式: <span class="math inline">\(\mathrm{Cov}(X,Y)=\mathbb{E}\!\left[(X-\mu_X)(Y-\mu_Y)\right]\)</span></li><li>自协方差和相关函数的关系: <span class="math inline">\(R_X(\tau) =m_X^2 + C_X(\tau)\)</span></li></ul></li><li>相关时间<ul><li>def: <span class="math inline">\(\tau_c=\int_{0}^{\infty}\rho_X(\tau)\,d\tau\)</span></li></ul></li><li>平均功率<ul><li><span class="math inline">\(P_{\text{avg}}=\mathbb{E}[X^2(t)]=R_X(0)\)</span></li></ul></li><li>总功率<ul><li><span class="math inline">\(P_{\text{total}}=P_{\text{DC}}+P_{\text{AC}}= m_X^2 + \big(R_X(0)-m_X^2\big)= m_X^2 + \sigma_X^2\)</span></li></ul></li><li>直流功率</li><li>交流功率</li></ol><p><img src="/2025/11/12/%E9%9A%8F%E6%9C%BA%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86-%E5%8A%9F%E7%8E%87%E8%B0%B1/功率分解.png" width="400"></p><p>proof(1):</p><h2 id="宽平稳过程">宽平稳过程</h2><p>经常用到的公式: 三角形的和差化积</p><h2 id="功率谱密度">功率谱密度</h2><p>常用性质: 频域时移</p><p>def: 对自相关函数/互相关函数做傅立叶变换得到功率谱密度</p><h2 id="白噪声">白噪声</h2><p><img src="/2025/11/12/%E9%9A%8F%E6%9C%BA%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86-%E5%8A%9F%E7%8E%87%E8%B0%B1/白噪声.png" width="400"></p></body></html>]]></content>
    
    
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;只为了考试！

过程的一些数字特征
 1. 均值 * 若功率谱连续则均值为0
    
    
 2. 自相关函数和互相关函数 * 自相关 &#92;(R_{X}(&#92;tau) = &#92;mathbb{E}[X(t)X(t+&#92;tau)]&#92;)
     * 互相关 &#92;(R_{XY}(&#92;tau) = &#92;mathbb{E}[X(t)Y(t+&#92;tau)]&#92;)
    
    
 3. 自相关系数 * def: &#92;(&#92;rho_X(&#92;tau)=&#92;frac{R_X(&#92;tau)}{R_X(0)},&#92;qquad &#92;rho_X(0)=1&#92;)
    
    
 4. 方差/协方差 * 方差计算公式: &#92;(Var(X) =&lt;/body&gt;&lt;/html&gt;</summary>
    
    
    
    <category term="本科课程" scheme="https://www.yechenblog.top/categories/%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="随机信号处理" scheme="https://www.yechenblog.top/categories/%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/%E9%9A%8F%E6%9C%BA%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"/>
    
    
    <category term="本科课程" scheme="https://www.yechenblog.top/tags/%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="随机信号处理" scheme="https://www.yechenblog.top/tags/%E9%9A%8F%E6%9C%BA%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>初识GTKWAVE</title>
    <link href="https://www.yechenblog.top/2025/11/08/%E5%88%9D%E8%AF%86GTKWAVE/"/>
    <id>https://www.yechenblog.top/2025/11/08/%E5%88%9D%E8%AF%86GTKWAVE/</id>
    <published>2025-11-08T02:20:20.000Z</published>
    <updated>2025-11-12T13:04:39.806Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><html><head></head><body><h2 id="编写testbench生成仿真文件">编写testbench生成仿真文件</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="comment">// 包含顶层模块的头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Vtop.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"verilated.h"</span></span></span><br><span class="line"><span class="comment">// 生成vcd格式的仿真文件所需头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"verilated_vcd_c.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>{</span><br><span class="line">  VerilatedContext* contextp = <span class="keyword">new</span> VerilatedContext; <span class="comment">// 创建一个上下文对象</span></span><br><span class="line">  VerilatedVcdC *tfp = <span class="keyword">new</span> VerilatedVcdC; <span class="comment">//创建一个VCD对象指针</span></span><br><span class="line">  contextp-&gt;<span class="built_in">commandArgs</span>(argc, argv); </span><br><span class="line">  Vtop* top = <span class="keyword">new</span> Vtop{contextp}; <span class="comment">// 在heap上构造一个对象 {}列表初始化</span></span><br><span class="line">  contextp-&gt;<span class="built_in">traceEverOn</span>(<span class="literal">true</span>); <span class="comment">// 打开上下文追踪</span></span><br><span class="line">  top-&gt;<span class="built_in">trace</span>(tfp, <span class="number">0</span>);</span><br><span class="line">  tfp-&gt;<span class="built_in">open</span>(<span class="string">"wave.vcd"</span>); <span class="comment">//保存波形文件的位置</span></span><br><span class="line">  <span class="comment">// 若上下文标记未完成，则一直循环</span></span><br><span class="line">  <span class="keyword">while</span> (!contextp-&gt;<span class="built_in">gotFinish</span>()) {</span><br><span class="line">    <span class="type">int</span> a = <span class="built_in">rand</span>() &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="built_in">rand</span>() &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 对top module的input进行复制</span></span><br><span class="line">    top-&gt;a = a;</span><br><span class="line">    top-&gt;b = b;</span><br><span class="line">    <span class="comment">// 更新output</span></span><br><span class="line">    top-&gt;<span class="built_in">eval</span>(); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d, b = %d, f = %d\n"</span>, a, b, top-&gt;f);</span><br><span class="line">    <span class="built_in">assert</span>(top-&gt;f == (a ^ b));</span><br><span class="line">    <span class="comment">// 写入wave.vcd</span></span><br><span class="line">    tfp-&gt;<span class="built_in">dump</span>(contextp-&gt;<span class="built_in">time</span>());</span><br><span class="line">    <span class="comment">// 增加上下文的时间</span></span><br><span class="line">    contextp-&gt;<span class="built_in">timeInc</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (contextp-&gt;<span class="built_in">time</span>() &gt; <span class="number">3</span>) {</span><br><span class="line">      contextp-&gt;<span class="built_in">gotFinish</span>(<span class="literal">true</span>); <span class="comment">//当上下文的时间超过3时标记完成</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 释放heap上面的对象</span></span><br><span class="line">  <span class="keyword">delete</span> top;</span><br><span class="line">  <span class="keyword">delete</span> contextp;</span><br><span class="line">  tfp-&gt;<span class="built_in">close</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>tips: 若要生成VCD文件</p><ol type="1"><li>打开上下文中的traceOn</li><li>将输入输出写进VCD对象中</li><li>通过VCD对象写入文件</li><li>编译时请加上<code>-trace</code></li></ol></body></html>]]></content>
    
    
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;编写testbench生成仿真文件
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42


#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;
// 包含顶层模块的头文件
#include &quot;Vtop.h&quot;
#include &quot;verilated.h&quot;
// 生成vcd格式的仿真文件所需头文件
#include &quot;verilated_vcd_c.h&quot;&lt;/assert.h&gt;&lt;/stdlib.h&gt;&lt;/stdio.h&gt;&lt;/body&gt;&lt;/html&gt;</summary>
    
    
    
    <category term="一生一芯" scheme="https://www.yechenblog.top/categories/%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF/"/>
    
    
    <category term="一生一芯" scheme="https://www.yechenblog.top/tags/%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF/"/>
    
    <category term="工具" scheme="https://www.yechenblog.top/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>初识Verilator</title>
    <link href="https://www.yechenblog.top/2025/11/07/%E5%88%9D%E8%AF%86Verilator/"/>
    <id>https://www.yechenblog.top/2025/11/07/%E5%88%9D%E8%AF%86Verilator/</id>
    <published>2025-11-07T14:57:00.000Z</published>
    <updated>2025-11-08T02:17:47.950Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><html><head></head><body><h2 id="verilator的工作原理">Verilator的工作原理</h2><p><img src="/2025/11/07/%E5%88%9D%E8%AF%86Verilator/Verilator使用指南.png"></p><ul><li><p>我们需要使用 C++ 编写激励文件。显然，我们不能在 testbench中直接调用我们 .v 中的模块，所以我们要通过 Verilator 将其转化为 C++文件再进行调用，Verilator为我们提供了顶层模块输入/输出引脚的接口，使我们得以对顶层模块的输入信号赋值或读取其输出信号。</p></li><li><p>Verilator 会生成一个 Makefile 脚本，利用 GCC 等编译器将生成的 C++文件和我们编写的激励文件编译成成用于仿真的可执行文件。</p></li></ul><h2 id="verilator-files">Verilator Files</h2><p><a href="https://verilator.org/guide/latest/files.html#files-read-written">RTFM</a></p><h2 id="verilator-command">Verilator Command</h2><figure class="highlight bash"><figcaption><span>shell</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man verilator</span><br></pre></td></tr></tbody></table></figure><h3 id="verilation生成可供调用的-c-文件">verilation(生成可供调用的 C++文件)</h3><figure class="highlight bash"><figcaption><span>shell</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&nbsp;verilator --cc [--top &lt;top-name&gt;] VerilogSourcefile</span><br></pre></td></tr></tbody></table></figure><ul><li><code>--cc</code>:指定将 Verilog 转化为 C++ 代码</li><li><code>--top</code>:当有多个Verilog 源文件的时候需要指定顶层模块</li><li><code>-Wall</code>:打开Verilator所有的警告</li><li><code>--Mdir &lt;directory&gt;</code>: 更改outputfile的路径，默认路径是obj_dir</li></ul><h3 id="编写testbench">编写testbench</h3><p>示例（双控开关）</p><figure class="highlight verilog"><figcaption><span>top.v</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top(</span><br><span class="line">  <span class="keyword">input</span> a,</span><br><span class="line">  <span class="keyword">input</span> b,</span><br><span class="line">  <span class="keyword">output</span> f</span><br><span class="line">);</span><br><span class="line">  <span class="keyword">assign</span> f = a ^ b;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><figcaption><span>main.cpp</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="comment">// 包含顶层模块的头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Vtop.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"verilated.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>{</span><br><span class="line">  VerilatedContext* contextp = <span class="keyword">new</span> VerilatedContext; <span class="comment">// 创建一个上下文对象</span></span><br><span class="line">  contextp-&gt;<span class="built_in">commandArgs</span>(argc, argv); </span><br><span class="line">  Vtop* top = <span class="keyword">new</span> Vtop{contextp}; <span class="comment">// 在heap上构造一个对象 {}列表初始化</span></span><br><span class="line">  <span class="comment">// 若上下文标记未完成，则一直循环</span></span><br><span class="line">  <span class="keyword">while</span> (!contextp-&gt;<span class="built_in">gotFinish</span>()) {</span><br><span class="line">    <span class="type">int</span> a = <span class="built_in">rand</span>() &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="built_in">rand</span>() &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 对top module的input进行复制</span></span><br><span class="line">    top-&gt;a = a;</span><br><span class="line">    top-&gt;b = b;</span><br><span class="line">    <span class="comment">// 更新output</span></span><br><span class="line">    top-&gt;<span class="built_in">eval</span>(); </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d, b = %d, f = %d\n"</span>, a, b, top-&gt;f);</span><br><span class="line">    <span class="built_in">assert</span>(top-&gt;f == (a ^ b));</span><br><span class="line">    <span class="comment">// 增加上下文的时间</span></span><br><span class="line">    contextp-&gt;<span class="built_in">timeInc</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (contextp-&gt;<span class="built_in">time</span>() &gt; <span class="number">3</span>) {</span><br><span class="line">      contextp-&gt;<span class="built_in">gotFinish</span>(<span class="literal">true</span>); <span class="comment">//当上下文的时间超过3时标记完成</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 释放heap上面的对象</span></span><br><span class="line">  <span class="keyword">delete</span> top;</span><br><span class="line">  <span class="keyword">delete</span> contextp;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="生成可执行文件并运行">生成可执行文件并运行</h3><figure class="highlight bash"><figcaption><span>shell</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&nbsp;verilator --cc -Wall [--top &lt;top-name&gt;] VerilogSourcefile -exe testbenchfile </span><br></pre></td></tr></tbody></table></figure><ul><li><code>-exe</code>:其实这步就是将testbenchfile加入到生成的Makefile中</li><li><code>-bulid</code>:构建可执行文件（自动执行Makefile），我们可以后面手动构建如果不加这个option</li></ul><p><img src="/2025/11/07/%E5%88%9D%E8%AF%86Verilator/exeoption.png"></p><h4 id="手动构建可执行文件">手动构建可执行文件</h4><figure class="highlight bash"><figcaption><span>shell</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -C obj_dir -f Vtop.mk Vtop</span><br></pre></td></tr></tbody></table></figure><ul><li><code>-C</code>: Change to directory dir before reading themakefiles or doing anything else.</li><li><code>-f</code>: Use file as a makefile</li></ul><p>最后的Vtop是make要构建的目标(Target)</p></body></html>]]></content>
    
    
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;Verilator的工作原理


 * 我们需要使用 C++ 编写激励文件。显然，我们不能在 testbench 中直接调用我们 .v 中的模块，所以我们要通过 Verilator 将其转化为 C++ 文件再进行调用，Verilator 为我们提供了顶层模块输入/输出引脚的接口，使我们得以对顶层模块的输入信号赋值或读取其输出信号。
   
   
 * Verilator 会生成一个 Makefile 脚本，利用 GCC 等编译器将生成的 C++ 文件和我们编写的激励文件编译成成用于仿真的可执行文件。
   
   

Verilator Files
RTFM

Verilator Comma&lt;/body&gt;&lt;/html&gt;</summary>
    
    
    
    <category term="一生一芯" scheme="https://www.yechenblog.top/categories/%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF/"/>
    
    
    <category term="一生一芯" scheme="https://www.yechenblog.top/tags/%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF/"/>
    
    <category term="工具" scheme="https://www.yechenblog.top/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>随记1</title>
    <link href="https://www.yechenblog.top/2025/11/07/%E9%9A%8F%E8%AE%B01/"/>
    <id>https://www.yechenblog.top/2025/11/07/%E9%9A%8F%E8%AE%B01/</id>
    <published>2025-11-07T14:35:41.000Z</published>
    <updated>2025-11-07T14:35:41.202Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><html><head></head><body><p>2025年11月7日晚</p><p>我常常想两年后的我会走上什么的路。考研上岸后读研究生？考研失败后找份工作？亦或者是二战？这样一看，考研对我来说是件很重要的事。</p><p>如果它对我很重要的话，为什么我现在就不开始准备呢？为什么还要浪费时间在做一生一芯上呢？我很纠结。学校课程的作业、家里的事、一生一芯、考研…花在这些事情上的时间往往不能平衡要有取舍。</p><p>现在支撑我做一生一芯的动力就是<strong>完成入学答辩</strong>了，毕竟也花了这么多时间在上面，也不知道是对还是错，希望以后的我不会对这个决定后悔吧！</p></body></html>]]></content>
    
    
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;2025年11月7日晚

我常常想两年后的我会走上什么的路。考研上岸后读研究生？考研失败后找份工作？亦或者是二战？这样一看，考研对我来说是件很重要的事。

如果它对我很重要的话，为什么我现在就不开始准备呢？为什么还要浪费时间在做一生一芯上呢？我很纠结。学校课程的作业、家里的事、一生一芯、考研…花在这些事情上的时间往往不能平衡要有取舍。

现在支撑我做一生一芯的动力就是完成入学答辩了，毕竟也花了这么多时间在上面，也不知道是对还是错，希望以后的我不会对这个决定后悔吧！&lt;/body&gt;&lt;/html&gt;</summary>
    
    
    
    <category term="随记" scheme="https://www.yechenblog.top/categories/%E9%9A%8F%E8%AE%B0/"/>
    
    
    <category term="随记" scheme="https://www.yechenblog.top/tags/%E9%9A%8F%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>信息论与编码2</title>
    <link href="https://www.yechenblog.top/2025/11/07/%E4%BF%A1%E6%81%AF%E8%AE%BA%E4%B8%8E%E7%BC%96%E7%A0%812/"/>
    <id>https://www.yechenblog.top/2025/11/07/%E4%BF%A1%E6%81%AF%E8%AE%BA%E4%B8%8E%E7%BC%96%E7%A0%812/</id>
    <published>2025-11-07T10:09:13.000Z</published>
    <updated>2025-11-11T14:26:27.551Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><html><head></head><body><h2 id="联合熵条件熵熵">联合熵、条件熵、熵</h2><p><span class="math display">\[ H(X, Y) = H(X) + H (Y|X)\]</span></p><p>proof:</p><p><span class="math display">\[\begin{aligned}H(X,Y)&amp;= -\sum_{x,y} p(x,y)\,\log p(x,y) \\&amp;= -\sum_{x,y} p(x,y)\,\log\!\big(p(x)\,p(y\mid x)\big) \\&amp;= -\sum_{x,y} p(x,y)\,\log p(x) \;-\; \sum_{x,y} p(x,y)\,\logp(y\mid x) \\&amp;= -\sum_{x} \Big(\sum_y p(x,y)\Big)\log p(x)   \;-\; \sum_x p(x)\sum_y p(y\mid x)\,\log p(y\mid x) \\&amp;= -\sum_x p(x)\log p(x)   \;+\; \sum_x p(x)\,\Big(-\sum_y p(y\mid x)\log p(y\mid x)\Big) \\&amp;= H(X) \;+\; \sum_x p(x)\,H(Y\mid X{=}x) \\&amp;= H(X)+H(Y\mid X).\end{aligned}\]</span></p><h2 id="记忆信源与无记忆信源">记忆信源与无记忆信源</h2><ul><li><p>记忆信源：符号出现的概率与之前出现过的符号有关</p></li><li><p>无记忆信源：符号出现的概率与之前出现过符号的概率无关，只由符号自身的概率决定</p></li></ul><p>tips: 离散信源的输出是一个符号表{x1, x2, x3…}</p><h2 id="二重信源">二重信源</h2><p>def: 把原信源连续的两个符号当成一个新符号来看的那个新信源</p><h2 id="马尔科夫信源">马尔科夫信源</h2><p>def: 即有记忆的离散信源</p><p>k阶马尔科夫信源：当前输出符号与前k个符号有关</p><h3 id="状态转移">状态转移</h3><p>类似于FSM（有限状态机）。 <a href="https://zh.wikipedia.org/wiki/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA">wikiabout FSM</a></p><h3 id="马尔科夫信源熵">马尔科夫信源熵</h3><ul><li><p>从一个状态到另一个状态发生转移并发出一个符号的熵</p></li><li><p>信源平均输出一个符号的熵（每个状态的熵的均值）</p></li></ul><h3 id="冗余度">冗余度</h3><p>def: <span class="math display">\[ R = 1 -\frac{H(x)}{H_{max}}\]</span></p><p>这里的 <span class="math inline">\(\frac{H(x)}{H_{max}}\)</span>也叫信源效率</p><p>该值越大说明符号之间的相关性越强，</p><h3 id="时间熵">时间熵</h3><p>def：平均每秒传递的信息量 (bit/s)</p><p>formular：</p><p><span class="math display">\[H_t = H(X) / E(T)\]</span></p><p>其中<span class="math inline">\(E(T)\)</span>为发送一个符号的平均时间，<span class="math inline">\(H(X)\)</span>为信源熵即一个符号带有的信息量</p><h2 id="编码">编码</h2><p>def: 为信源发出的每个符号进行编码</p><h3 id="香农编码">香农编码</h3><p>如何进行香农编码: <img src="/2025/11/07/%E4%BF%A1%E6%81%AF%E8%AE%BA%E4%B8%8E%E7%BC%96%E7%A0%812/香农编码.png" width="500"></p><h3 id="哈夫曼编码">哈夫曼编码</h3><p>如何进行哈夫曼编码: <a href="https://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81#:~:text=Fig.1%E3%80%82-,%E6%BC%94%E7%AE%97%E8%BF%87%E7%A8%8B,-%5B%E7%BC%96%E8%BE%91%5D">wikiabout Huffman</a></p><h3 id="编码速率和编码效率">编码速率和编码效率</h3><p>def: 编码速率即平均码长（bit/符号）</p><p><span class="math display">\[\bar L = \sum_{i=1}^{\infty}p_i\,l_i\]</span></p><p>def: 编码效率即信源熵/平均码长</p><p><span class="math display">\[\eta = \frac{H(X)}{\bar{L}}\]</span></p><p>重要关系</p><ul><li><span class="math inline">\(H(X) \leq \bar L\)</span></li></ul><p>即信源熵是平均码长的下界，信源熵是一个信源发出一个符号带来的<strong>平均不确定度/信息量（需要多少bit去表示这个符号的发生）</strong>，而平均码长就是该编码表示一个符号的平均bits，当二者越接近说明这种编码方式的效率越高.</p><h2 id="离散信道容量">离散信道容量</h2><p>Reveiw:</p><p><code>互信息(Mutual Information)</code>:是一个衡量“知道一个变量能减少另一个变量多少不确定性”的量，或者说二者<strong><em>共享的信息量</em></strong>。</p><p>数学定义为:<span class="math inline">\(I(X;Y) = H(X) -H(X|Y)\)</span></p><h3 id="信道容量">信道容量</h3><table><colgroup><col style="width: 22%"><col style="width: 44%"><col style="width: 33%"></colgroup><thead><tr><th>目标</th><th>量</th><th>意义</th></tr></thead><tbody><tr><td>想看输出反映输入多少</td><td><span class="math inline">\(I(X;Y)\)</span></td><td>输入输出共享信息量</td></tr><tr><td>想找信道能力上限</td><td><span class="math inline">\(\max_{p(x)} I(X;Y)\)</span></td><td>最优输入分布下的最大共享信息量</td></tr></tbody></table><p>数学定义:</p><p><span class="math display">\[C =\max_{p(x)} I(X;Y)\]</span></p><p>当信道矩阵(转移概率矩阵)对称时有:</p><p><span class="math display">\[C = log_{2}M - H(Y|X)\]</span></p><h3 id="理想观测器">理想观测器</h3><p>什么是理想观测器(摘自ChatGPT5) <img src="/2025/11/07/%E4%BF%A1%E6%81%AF%E8%AE%BA%E4%B8%8E%E7%BC%96%E7%A0%812/理想观测器.png"></p><p>即根据条件概率选择当观测到某个y时，它的输入为x。</p><h3 id="误判概率">误判概率</h3><p>设计的理想观测器的误判概率</p><h2 id="question">Question</h2><ol type="1"><li>几何级数和几何级数求导求和？</li></ol></body></html>]]></content>
    
    
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;联合熵、条件熵、熵
&#92;[ H(X, Y) = H(X) + H (Y|X)&#92;]

proof:

&#92;[ &#92;begin{aligned} H(X,Y) &amp;amp;= -&#92;sum_{x,y} p(x,y)&#92;,&#92;log p(x,y) &#92;&#92; &amp;amp;= -&#92;sum_{x,y} p(x,y)&#92;,&#92;log&#92;!&#92;big(p(x)&#92;,p(y&#92;mid x)&#92;big) &#92;&#92; &amp;amp;= -&#92;sum_{x,y} p(x,y)&#92;,&#92;log p(x) &#92;;-&#92;; &#92;sum_{x,y} p(x,y)&#92;,&#92;log p(y&#92;mid x) &#92;&#92; &amp;amp;= -&#92;sum_{x} &#92;Big(&#92;sum_y p(x,y)&#92;Big)&#92;log p(x) &#92;;-&#92;;&lt;/body&gt;&lt;/html&gt;</summary>
    
    
    
    <category term="本科课程" scheme="https://www.yechenblog.top/categories/%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="信息论与编码" scheme="https://www.yechenblog.top/categories/%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E8%AE%BA%E4%B8%8E%E7%BC%96%E7%A0%81/"/>
    
    
    <category term="信息论与编码" scheme="https://www.yechenblog.top/tags/%E4%BF%A1%E6%81%AF%E8%AE%BA%E4%B8%8E%E7%BC%96%E7%A0%81/"/>
    
    <category term="本科课程" scheme="https://www.yechenblog.top/tags/%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>4.1 Orthogonality of the four subspaces</title>
    <link href="https://www.yechenblog.top/2025/11/07/4-1-Orthogonality-of-the-four-subspaces/"/>
    <id>https://www.yechenblog.top/2025/11/07/4-1-Orthogonality-of-the-four-subspaces/</id>
    <published>2025-11-06T16:50:01.000Z</published>
    <updated>2025-11-07T04:46:37.789Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><html><head></head><body><h2 id="总结">总结</h2><p><img src="/2025/11/07/4-1-Orthogonality-of-the-four-subspaces/conclusion.png"></p><p>对于这些内容接下来会一一解释</p><h2 id="向量之间的正交">向量之间的正交</h2><p><img src="/2025/11/07/4-1-Orthogonality-of-the-four-subspaces/vectors.png"></p><h2 id="空间之间的正交">空间之间的正交</h2><p>Def:两个空间相互正交，即在这两个空间中，分别取任意一个向量，这两个向量都正交</p><p>Ex: <img src="/2025/11/07/4-1-Orthogonality-of-the-four-subspaces/不正交的两个空间.png" width="200"></p><h3 id="正交补空间">正交补空间</h3><p>直观上：子空间<span class="math inline">\(U\)</span>和正交补空间<span class="math inline">\(U^{\perp}\)</span>的和构成了整个空间，即该空间中的一个向量可以分解为<span class="math inline">\(U\)</span>中的一个向量加上<span class="math inline">\(U^\perp\)</span>中的一个向量。</p><p>若<span class="math inline">\(U\)</span>和<span class="math inline">\(U\perp\)</span>都为<span class="math inline">\(R^n\)</span>的子空间，则有以下性质</p><ol type="1"><li><span class="math inline">\(dimU + dimU^\perp = n\)</span></li></ol><h2 id="四个子空间之间的关系">四个子空间之间的关系</h2><p><img src="/2025/11/07/4-1-Orthogonality-of-the-four-subspaces/四个子空间之间的关系.png"></p><ol type="1"><li>列空间和左零空间相互正交</li><li>行空间和零空间相互正交</li><li>方程<span class="math inline">\(Ax=b\)</span>中的x位于<span class="math inline">\(R^n\)</span>空间中</li><li>若矩阵A可逆，行空间中的所有向量与列空间中的向量一一对应</li></ol><h3 id="第二点的证明如下">第二点的证明如下:</h3><p><img src="/2025/11/07/4-1-Orthogonality-of-the-four-subspaces/行空间与零空间正交补.png"></p><ol type="1"><li>每一行与零空间的向量的点乘都为0</li><li>每个行向量之间的线性组合与零空间的点乘也为0 -&gt;线性组合构成行空间中的任意一个向量</li></ol><p>除此之外可以用代数的方法证明：</p><p><span class="math display">\[x^T(A^T y) = (Ax)^T y = 0\]</span></p><h3 id="第三第四点证明如下">第三第四点证明如下:</h3><p>第三点很显然，因为x有n个分量，肯定在<span class="math inline">\(R^n\)</span>中，根据正交补空间的性质，x就可以分解为<span class="math inline">\(x = x_{row} + x_{null}\)</span></p><p>故 <span class="math display">\[Ax = A(x_{row} + x_{null}) = Ax_{row}+ 0\]</span></p><p>当矩阵A不可逆的时候是做不到列空间中的向量与行空间中的向量一一对应的，因为存在着零空间的分量。但是当可逆的时候，零空间只有0。</p></body></html>]]></content>
    
    
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;总结


对于这些内容接下来会一一解释

向量之间的正交


空间之间的正交
Def: 两个空间相互正交，即在这两个空间中，分别取任意一个向量，这两个向量都正交

Ex: 

正交补空间
直观上：子空间&#92;(U&#92;)和正交补空间&#92;(U^{&#92;perp}&#92;)的和构成了整个空间，即该空间中的一个向量可以分解为&#92;(U&#92;)中的一个向量加上&#92;(U^&#92;perp&#92;)中的一个向量。

若&#92;(U&#92;)和&#92;(U&#92;perp&#92;)都为&#92;(R^n&#92;)的子空间，则有以下性质

 1. &#92;(dimU + dimU^&#92;perp = n&#92;)

四个子空间之间的关系


 1. 列空间和左零空间相互正交
 2. 行空间和零空间相互正交
 &lt;/body&gt;&lt;/html&gt;</summary>
    
    
    
    <category term="线性代数" scheme="https://www.yechenblog.top/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    
    <category term="线性代数" scheme="https://www.yechenblog.top/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    <category term="数学" scheme="https://www.yechenblog.top/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>helloworld</title>
    <link href="https://www.yechenblog.top/2025/11/06/helloworld/"/>
    <id>https://www.yechenblog.top/2025/11/06/helloworld/</id>
    <published>2025-11-06T13:51:27.000Z</published>
    <updated>2025-11-06T13:51:27.830Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><html><head></head><body><p>Hello world!</p></body></html>]]></content>
    
    
    <summary type="html">&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;Hello world!&lt;/body&gt;&lt;/html&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
