{"meta":{"title":"Yechen's Blog","subtitle":"随便写写","description":"道路曲折 光明在前","author":"Yechen","url":"https://www.yechenblog.top","root":"/"},"pages":[{"title":"categories","date":"2025-11-06T07:39:10.000Z","updated":"2025-11-06T07:39:26.540Z","comments":true,"path":"categories/index.html","permalink":"https://www.yechenblog.top/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2025-11-06T13:32:58.000Z","updated":"2025-11-13T15:41:29.970Z","comments":true,"path":"about/index.html","permalink":"https://www.yechenblog.top/about/index.html","excerpt":"本科就读于深圳大学，专业为电子信息工程的咸鱼一条","text":"本科就读于深圳大学，专业为电子信息工程的咸鱼一条"},{"title":"tags","date":"2025-11-06T05:20:52.000Z","updated":"2025-11-06T07:38:11.549Z","comments":true,"path":"tags/index.html","permalink":"https://www.yechenblog.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"无符号和补码共用一个加法器","slug":"无符号和补码共用一个加法器","date":"2025-11-24T12:07:38.000Z","updated":"2025-11-24T12:07:53.532Z","comments":true,"path":"2025/11/24/无符号和补码共用一个加法器/","permalink":"https://www.yechenblog.top/2025/11/24/%E6%97%A0%E7%AC%A6%E5%8F%B7%E5%92%8C%E8%A1%A5%E7%A0%81%E5%85%B1%E7%94%A8%E4%B8%80%E4%B8%AA%E5%8A%A0%E6%B3%95%E5%99%A8/","excerpt":"我们要证明的核心命题是： 同一个二进制加法电路（即模 \\(2^n\\)加法），既实现了无符号数加法，也实现了补码加法。 我们将分为三个步骤进行证明： 1. 定义 (Definition)：严格定义位向量、无符号数值和补码数值。 2.引理 (Lemma)：证明无符号值和补码值在模 \\(2^n\\) 下同余。 3. 定理 (Theorem)：证明加法闭环。 第一步：定义 (Definitions) 设 \\(X\\) 为一个 \\(n\\) 位的二进制向量，其位序列为 \\(x_{n-1}x_{n-2}\\dots x_0\\)，其中 \\(x_i \\in \\{0, 1\\}\\)。 1. 无符号数的值函数","text":"我们要证明的核心命题是： 同一个二进制加法电路（即模 \\(2^n\\) 加法），既实现了无符号数加法，也实现了补码加法。 我们将分为三个步骤进行证明： 1. 定义 (Definition)：严格定义位向量、无符号数值和补码数值。 2. 引理 (Lemma)：证明无符号值和补码值在模 \\(2^n\\) 下同余。 3. 定理 (Theorem)：证明加法闭环。 第一步：定义 (Definitions) 设 \\(X\\) 为一个 \\(n\\) 位的二进制向量，其位序列为 \\(x_{n-1}x_{n-2}\\dots x_0\\)，其中 \\(x_i \\in \\{0, 1\\}\\)。 1. 无符号数的值函数 \\(U(X)\\) 无符号数将所有位都视为正权重： \\[U(X) = \\sum_{i=0}^{n-1} x_i 2^i = x_{n-1}2^{n-1} + \\sum_{i=0}^{n-2} x_i 2^i\\] 取值范围：\\([0, 2^n - 1]\\)。 2. 补码的值函数 \\(T(X)\\) 补码将最高位（符号位）视为负权重，其余位为正权重： \\[T(X) = -x_{n-1}2^{n-1} + \\sum_{i=0}^{n-2} x_i 2^i\\] 取值范围：\\([-2^{n-1}, 2^{n-1} - 1]\\)。 3. 硬件加法器的行为函数 \\(Hardware_{Add}(X, Y)\\) 硬件加法器是一个逻辑电路，它输入两个 \\(n\\) 位向量 \\(X, Y\\)，输出一个 \\(n\\) 位向量 \\(S\\)。 其物理行为严格等价于无符号数的模 \\(2^n\\) 加法（因为超过 \\(n\\) 位的进位会被物理截断）： \\[U(S) = (U(X) + U(Y)) \\pmod{2^n}\\] 即： \\[U(S) \\equiv U(X) + U(Y) \\pmod{2^n}\\] 第二步：引理 (Fundamental Lemma) 引理： 对于任意 \\(n\\) 位二进制向量 \\(X\\)，其无符号值 \\(U(X)\\) 与补码值 \\(T(X)\\) 模 \\(2^n\\) 同余。 \\[U(X) \\equiv T(X) \\pmod{2^n}\\] 证明： 我们将两者的定义式相减： \\[ \\begin{aligned} U(X) - T(X) &amp;= \\left( x_{n-1}2^{n-1} + \\sum_{i=0}^{n-2} x_i 2^i \\right) - \\left( -x_{n-1}2^{n-1} + \\sum_{i=0}^{n-2} x_i 2^i \\right) \\\\ &amp;= x_{n-1}2^{n-1} - (-x_{n-1}2^{n-1}) \\\\ &amp;= 2 \\cdot (x_{n-1}2^{n-1}) \\\\ &amp;= x_{n-1} \\cdot 2^n \\end{aligned} \\] 分析结果： * \\(x_{n-1}\\) 是最高位，只能取 0 或 1。 * 因此，\\(U(X) - T(X)\\) 要么是 0，要么是 \\(2^n\\)。 * 在模 \\(2^n\\) 算术中，\\(k \\cdot 2^n \\equiv 0 \\pmod{2^n}\\)。 结论： \\[U(X) - T(X) \\equiv 0 \\pmod{2^n} \\implies U(X) \\equiv T(X) \\pmod{2^n}\\] (证明完毕) 物理意义解释：这一步证明了，虽然数学上数值不同，但在计算机的 \\(n\\) 位存储空间里，它们属于同一个同余类。这是后续所有推导的基石。 第三步：定理证明 (The Main Proof) 定理： 设 \\(X, Y\\) 为两个 \\(n\\) 位补码数，设 \\(S\\) 为硬件加法器产生的二进制结果。则 \\(S\\) 的补码值 \\(T(S)\\) 模 \\(2^n\\) 同余于 \\(T(X) + T(Y)\\)。 证明过程： 根据硬件定义（参见第一步第3点），加法器生成的结果 \\(S\\) 满足： \\[U(S) \\equiv U(X) + U(Y) \\pmod{2^n} \\quad \\text{------ (式1)}\\] 利用引理（参见第二步），我们可以将式1右边的无符号项 \\(U(X)\\) 和 \\(U(Y)\\) 替换为补码项： 因为 \\(U(X) \\equiv T(X) \\pmod{2^n}\\) 且 \\(U(Y) \\equiv T(Y) \\pmod{2^n}\\)，根据模运算加法性质，代入式1得： \\[U(S) \\equiv T(X) + T(Y) \\pmod{2^n} \\quad \\text{------ (式2)}\\] 再次利用引理，将式2左边的无符号结果 \\(U(S)\\) 替换为补码结果 \\(T(S)\\)： 因为对于任意向量（包括 \\(S\\)）都有 \\(U(S) \\equiv T(S) \\pmod{2^n}\\)，代入式2得： \\[T(S) \\equiv T(X) + T(Y) \\pmod{2^n} \\quad \\text{------ (式3)}\\] 结论： \\[T(S) \\equiv T(X) + T(Y) \\pmod{2^n}\\] 详细解释与最终结论 我们得到了最终公式： \\[T(S) = T(X) + T(Y) + k \\cdot 2^n \\quad (k \\in \\mathbb{Z})\\] 这说明了什么？ 运算的正确性： 虽然硬件是按照无符号逻辑（模 \\(2^n\\)）运行的，但生成的结果 \\(S\\) 的补码值 \\(T(S)\\)，与我们期望的数学结果 \\(T(X) + T(Y)\\) 只相差 \\(2^n\\) 的整数倍。 为什么这就足够了？ 在 \\(n\\) 位补码系统中，能够表示的数值范围是有限的：\\([-2^{n-1}, 2^{n-1}-1]\\)。 在这个范围内，任何两个不同的数，其差值绝对不可能等于 \\(2^n\\) 的倍数（因为范围跨度本身就是 \\(2^n\\)）。 这意味着： 在模 \\(2^n\\) 的剩余系中，只要结果没有溢出（Overflow），能够落入这个合法范围的解是唯一的。 溢出判断 (Overflow)： 如果 \\(T(X) + T(Y)\\) 的真实结果超出了补码的表示范围，那么硬件计算出的 \\(T(S)\\) 会因为模 \\(2^n\\) 的作用“回绕”到范围的另一头（例如正数加成负数）。 这就是为什么我们需要一个额外的 \\(Overflow\\) 标志位。 只要 \\(Overflow = 0\\)，则 \\(k=0\\)，此时严格成立： \\[T(S) = T(X) + T(Y)\\] 最终陈述： 该数学证明展示了补码系统与模算术系统的同构性。正是因为 \\(T(X)\\) 和 \\(U(X)\\) 在模 \\(2^n\\) 下是等价的，所以我们不需要设计两套加法电路。一套模 \\(2^n\\) 的电路（即普通的二进制加法器）就足以同时处理这两种数学模型，唯一的区别在于我们如何解读结果（位级模式）以及如何检测溢出。","categories":[],"tags":[]},{"title":"信息的表示和处理","slug":"信息的表示和处理","date":"2025-11-19T14:50:32.000Z","updated":"2025-11-23T15:33:39.607Z","comments":true,"path":"2025/11/19/信息的表示和处理/","permalink":"https://www.yechenblog.top/2025/11/19/%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/","excerpt":"码制 不同的 码制 即对 位模式做出不同的解释。 原码反码补码最高位作为符号位\\(-2^{w - 1} - 1\\)\\(-2^w\\)符号位取反$2^w - 1 - x $$2^w - x $第二行是不同码制对最高位的解释，第三行是已知 x 如何求-x 的表示 原码 为了区分正数和负数，用最高位当作符号位。这样符合人类的直觉，但对计算机计算很不友好。比如: 计算 \\(1 + (-1)\\) * 原码表示 0001 + 1001 * 如果是纯加法电路会得到 0001 + 1001 =1010 (结果为-2)，计算有误。 这意味着，如果用原码来表示数字，CPU的计算单元(ALU)必须设计的","text":"码制 不同的 码制 即对 位模式 做出不同的解释。 原码 反码 补码 最高位作为符号位 \\(-2^{w - 1} - 1\\) \\(-2^w\\) 符号位取反 $2^w - 1 - x $ $2^w - x $ 第二行是不同码制对最高位的解释，第三行是已知 x 如何求 -x 的表示 原码 为了区分正数和负数，用最高位当作符号位。这样符合人类的直觉，但对计算机计算很不友好。比如: 计算 \\(1 + (-1)\\) 原码表示 0001 + 1001 如果是纯加法电路会得到 0001 + 1001 = 1010 (结果为-2)，计算有误。 这意味着，如果用原码来表示数字，CPU的计算单元(ALU)必须设计的十分复杂。他必须先判断符号位: 如果符号相同做加法 如果符号不相同，比较绝对值的大小，用大的减小的，最后决定结果的符号。 为了解决这一问题，就有了反码 反码 要了解反码，就要了解反码是怎么来的 反码的来源 早在机械计算器时代（比如 17 世纪帕斯卡的加法机），人们就在思考：“怎样把该死的减法变成加法？” 因为制造一个能倒着转、能处理“借位”的齿轮装置，比制造一个只管顺着转、只管“进位”的装置要复杂得多。 比如有个只能处理 0~99 的机器，我们要计算 56 - 13，但是我们不想让其倒着转(减法)，我们可以通过让 56 加上 13 的反码 99 - 13 = 86，让机器一直顺着转(加法)，即可。最后得到的结果为 \\[ 56 + 86 = 142\\] 与正确结果有误差，我们只用把进位 1 加上即可 42 + 1 = 43 二进制中的反码 根据上述的故事，我们就可以定义反码了: \\[-x_反 = 2^w - 1 - x_反\\] 即用 11111...11 - x，这在电路中非常容易实现，只需用一个 反相器(NOT GATE) 即可。 根据这个定义，我们就可以推导出最高位的数值为 \\(2^{w-1} - 1\\) 处理溢出 计算 \\(A - B\\) A &gt; B \\[ \\begin{aligned} A + (2^w - 1 - B) &amp;= 2^w + (A - B - 1) \\\\ &amp;= A - B - 1 \\end{aligned} \\] 最后得到的结果比实际的结果少1 A &lt; B \\[ \\begin{aligned} A + (2^w - 1 - B) &amp;= 2^w - 1 - (B - A) \\end{aligned} \\] 最后得到B - A的反码表示，与结果符合(因为B - A的反码的值就是-(B - A) = A - B) 补码 为了解决反码中溢出的问题，我们定义: \\[ -x_补 = 2^w - x_补\\] 通过该定义也可以推导出，补码最高位的数值为\\(-2^{w-1}\\) 补码与反码的关系 \\[ -x_补 = -x_反 + 1 \\] 推导如下: \\[ \\begin{aligned} -x_补 &amp;= 2^w - x_补 \\\\ &amp;= (2^w - 1 - x_补) + 1 \\\\ &amp;= -x_反 + 1 \\end{aligned} \\] 有符号和无符号之间的转化 设 x 为一个位向量，其位模式可以表示为 \\([x_{w - 1}, x_{w - 2}, x_{w - 3} ... , x_0]\\) 定义如下函数: B2U(x) = \\(\\sum_{i=0}^{w-1}2^{i}x_i\\) B2T(x) = \\(-x_{w-1}2^{w-1} + \\sum_{i=0}^{w-2}2^{i}x_i\\) 根据以上定义，我们可以得到同一个 位模式 ，不同的解释方式(补码或者无符号)得到的值有如下的关系: \\[ \\begin{aligned} B2U(x) - B2T(x) &amp;= x_{w-1}2^{w} \\\\ B2T(x) &amp;= B2U(x) - x_{w-1}2^{w}\\\\ \\end{aligned} \\] 整数运算 无符号加法和补码加法 计算中用同一个加法器去处理无符号加法和补码加法 x 和 y: 都为位宽为 w 的位向量。 \\(x_{u}、y_{u}、x_{s}、y_{s}\\)为x和y的无符号和补码表示。 因为我们限制了结果只能用 w 位表示，所以值上有如下关系: 无符号加法: \\[ x_{u} + y_{u} = (x_{u} + y_{u})(mod\\ 2^w) \\] 补码加法: \\[ \\begin{aligned} x_{t} + y_{t} = U2T(x_{u} + y_{u}) \\end{aligned} \\] 具体溢出等情况可以参考CSAPP中的内容(P60)","categories":[{"name":"计组","slug":"计组","permalink":"https://www.yechenblog.top/categories/%E8%AE%A1%E7%BB%84/"}],"tags":[{"name":"计组","slug":"计组","permalink":"https://www.yechenblog.top/tags/%E8%AE%A1%E7%BB%84/"}]},{"title":"从c语言到二进制代码","slug":"从c语言到二进制代码","date":"2025-11-19T02:53:05.000Z","updated":"2025-11-19T02:56:14.576Z","comments":true,"path":"2025/11/19/从c语言到二进制代码/","permalink":"https://www.yechenblog.top/2025/11/19/%E4%BB%8Ec%E8%AF%AD%E8%A8%80%E5%88%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BB%A3%E7%A0%81/","excerpt":"从c语言到二进制代码可分为 预处理 -&gt; 编译 -&gt; 汇编-&gt; 链接 这四个过程 预处理","text":"从c语言到二进制代码可分为 预处理 -&gt; 编译 -&gt; 汇编 -&gt; 链接 这四个过程 预处理","categories":[{"name":"一生一芯","slug":"一生一芯","permalink":"https://www.yechenblog.top/categories/%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF/"}],"tags":[{"name":"一生一芯","slug":"一生一芯","permalink":"https://www.yechenblog.top/tags/%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF/"}]},{"title":"随记3","slug":"随记3","date":"2025-11-18T02:39:48.000Z","updated":"2025-11-18T02:46:13.249Z","comments":true,"path":"2025/11/18/随记3/","permalink":"https://www.yechenblog.top/2025/11/18/%E9%9A%8F%E8%AE%B03/","excerpt":"我是个很幸运的人，在这21年中我受到了来自很多人的帮助和关爱。即使我也受到了很多挫折，但是幸运的是我没被打倒。 最近几年发生了很多事，可以说是彻底改变了我。我的女朋友给予了我很大帮助，我非常非常感谢她，也觉得非常幸运能遇到她。","text":"我是个很幸运的人，在这21年中我受到了来自很多人的帮助和关爱。即使我也受到了很多挫折，但是幸运的是我没被打倒。 最近几年发生了很多事，可以说是彻底改变了我。我的女朋友给予了我很大帮助，我非常非常感谢她，也觉得非常幸运能遇到她。","categories":[{"name":"随记","slug":"随记","permalink":"https://www.yechenblog.top/categories/%E9%9A%8F%E8%AE%B0/"}],"tags":[{"name":"随记","slug":"随记","permalink":"https://www.yechenblog.top/tags/%E9%9A%8F%E8%AE%B0/"}]},{"title":"接入NVBoard","slug":"接入NVBoard","date":"2025-11-12T08:50:52.000Z","updated":"2025-11-13T15:40:50.381Z","comments":true,"path":"2025/11/12/接入NVBoard/","permalink":"https://www.yechenblog.top/2025/11/12/%E6%8E%A5%E5%85%A5NVBoard/","excerpt":"Makefile 为了搞懂NVBoard是怎么工作的，先看一下它的构建规则是怎么样的 其构建规则在/scripts/nvboard.mk中，Makefile的一些补充知识 1. 自动变量: $@: 目标 $&lt;: 第一个依赖 $^: 所有依赖(去重) $+: 所有依赖(不去重) 2. 命令前加@，不在终端中显示该命令，但仍会显示输出 3. 内建变量: CXX: cpp编译器 CC: c编译器 CPPFLAGS: 编译器选项","text":"Makefile 为了搞懂NVBoard是怎么工作的，先看一下它的构建规则是怎么样的 其构建规则在/scripts/nvboard.mk中，Makefile的一些补充知识 自动变量: $@: 目标 $&lt;: 第一个依赖 $^: 所有依赖(去重) $+: 所有依赖(不去重) 命令前加@，不在终端中显示该命令，但仍会显示输出 内建变量: CXX: cpp编译器 CC: c编译器 CPPFLAGS: 编译器选项 CFLAGS 赋值 =: 展开赋值(动态值),使用时才赋值 :=: 立即赋值(静态值) +=: 追加赋值 ?=: 条件赋值，只有在没有被定义的时候才会赋值 同名目标的多个规则会合并 依赖中的变量会在读取Makefile时展开(编读边展开)，而规则中的变量会在使用时展开。而Makefile会读取完整个文件后再执行对应的规则 Makefile 默认的 target 是 file 中的第一个 target 接入NVBoard(流水灯) 编写Makefile 参考NVBoard/example中的Makefile，但有几点是要注意的","categories":[{"name":"一生一芯","slug":"一生一芯","permalink":"https://www.yechenblog.top/categories/%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF/"}],"tags":[{"name":"一生一芯","slug":"一生一芯","permalink":"https://www.yechenblog.top/tags/%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF/"},{"name":"Makefile","slug":"Makefile","permalink":"https://www.yechenblog.top/tags/Makefile/"}]},{"title":"Projection Matrices and Least Squares","slug":"Projection-Matrices-and-Least-Squares","date":"2025-11-12T08:03:59.000Z","updated":"2025-11-15T10:07:33.958Z","comments":true,"path":"2025/11/12/Projection-Matrices-and-Least-Squares/","permalink":"https://www.yechenblog.top/2025/11/12/Projection-Matrices-and-Least-Squares/","excerpt":"投影(Projection) 概要 投影矩阵、投影、误差向量 目标: 找出向量b在空间S上的投影p，以及产生p的矩阵P 误差向量: \\(e = b - p = A \\hat x\\) tips: A 是空间 S 的基向量构成的矩阵 方法: 根据几何关系可以得到\\(e\\)与空间S正交。描述一个空间的最好方法就是用基向量描述，把基向量放入矩阵A中，该矩阵的列空间即为空间S，由\\(e \\perp S\\)，得到\\(e \\in LN(S)\\)，即误差向量在S的左零空间中。 下图是图例: 由上述关系可得: \\[ \\begin{aligned} A^\\top (b - A\\hat x) &amp;=","text":"投影(Projection) 概要 投影矩阵、投影、误差向量 目标: 找出向量b在空间S上的投影p，以及产生p的矩阵P 误差向量: \\(e = b - p = A \\hat x\\) tips: A 是空间 S 的基向量构成的矩阵 方法: 根据几何关系可以得到\\(e\\)与空间S正交。描述一个空间的最好方法就是用基向量描述，把基向量放入矩阵A中，该矩阵的列空间即为空间S，由\\(e \\perp S\\)，得到\\(e \\in LN(S)\\)，即误差向量在S的左零空间中。 下图是图例: 由上述关系可得: \\[ \\begin{aligned} A^\\top (b - A\\hat x) &amp;= 0 \\\\ \\hat x &amp;= (A^\\top A)^{-1}A^\\top b \\\\ p &amp;= Ax = A(A^\\top A)^{-1}A^\\top b \\\\ P &amp;= A(A^\\top A)^{-1}A^\\top \\end{aligned} \\] 最小二乘法(Least Squares) 目的: \\(Ax = b\\)有时候无解,我们为了找到最接近的(误差最小的解),可以去解\\(A\\hat x=p\\),其中\\(b = p + e\\) 上图是最直观的一幅图，有以下几点需要注意 A是线性无关的列构成的矩阵，所以其零空间只有0 因为列空间和左零空间互为正交补空间，所以b能分解为\\(p+e\\) 将b投影到p的投影矩阵是P,而投影到e的投影矩阵是I-P 第三点的证明: 我们已知\\(b = p + e\\),而\\(p = Pb\\),简单代数运算后得到\\(e = (I-P)b\\),然后再证明e在A的左零空间中. \\[ \\begin{aligned} P &amp;= A (A^T A)^{-1} A^T \\\\ A^T P &amp;= A^T \\bigl(A (A^T A)^{-1} A^T \\bigr) \\\\ &amp;= (A^T A)(A^T A)^{-1} A^T \\\\ &amp;= A^T \\\\ A^T(I-P) &amp;= A^T - A^T P = 0 \\\\ A^T(I-P)\\mathbf b &amp;= 0 \\\\ \\end{aligned} \\] 另一个证明: \\[ \\begin{aligned} e &amp;= b - p \\\\ Pe &amp; = P(b - p)\\\\ &amp;= p - p \\\\ &amp; = 0 \\end{aligned} \\] ## \\(A^TA\\)的可逆性证明 前提条件: A的列向量是线性无关的 proof: 要证\\(A^TA\\)可逆，即证\\(A^TAx=0\\)的解只有零向量 \\[ \\begin{aligned} suppose: A^TAx &amp;= 0 \\\\ x^TA^TAx &amp;=0 \\\\ (Ax)^TAx &amp;=0 \\\\ Ax = 0 \\\\ \\end{aligned} \\] 最后得到只需要证明\\(Ax=0\\)，但我们的前提条件是A的列向量之间是线性无关的，所以证毕 补充 若b在子空间S中，则\\(Pb = b\\)。反之也成立。 若b垂直于子空间S，则\\(Pb = 0\\)。反之也成立。 第一条证明: 因为b在子空间S中，所以b为列向量的线性组合，即\\(b = Ax\\) \\[ \\begin{aligned} P &amp;= A(A^TA)^{-1}A^T \\\\ Pb &amp;= A(A^TA)^{-1}A^Tb \\\\ &amp;= A(A^TA)^{-1}A^TAx \\\\ &amp;= A(A^TA)^{-1}(A^TA)x \\\\ &amp;= Ax \\\\ &amp;= b \\\\ \\end{aligned} \\] 第二条证明: 因为b垂直于子空间S，则\\(b \\in S^\\perp\\)，所以\\(A^Tb = 0\\) \\[ \\begin{aligned} P &amp;= A(A^TA)^{-1}A^T \\\\ Pb &amp;= A(A^TA)^{-1}A^Tb \\\\ &amp;= 0 \\end{aligned} \\]","categories":[{"name":"线性代数","slug":"线性代数","permalink":"https://www.yechenblog.top/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"}],"tags":[{"name":"线性代数","slug":"线性代数","permalink":"https://www.yechenblog.top/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"数学","slug":"数学","permalink":"https://www.yechenblog.top/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"随记2","slug":"随记2","date":"2025-11-12T07:21:56.000Z","updated":"2025-11-12T07:23:33.305Z","comments":true,"path":"2025/11/12/随记2/","permalink":"https://www.yechenblog.top/2025/11/12/%E9%9A%8F%E8%AE%B02/","excerpt":"路还很长，对自己不要太严格了，take it easy.","text":"路还很长，对自己不要太严格了，take it easy.","categories":[{"name":"随记","slug":"随记","permalink":"https://www.yechenblog.top/categories/%E9%9A%8F%E8%AE%B0/"}],"tags":[{"name":"随记","slug":"随记","permalink":"https://www.yechenblog.top/tags/%E9%9A%8F%E8%AE%B0/"}]},{"title":"随机信号处理-功率谱","slug":"随机信号处理-功率谱","date":"2025-11-12T02:26:26.000Z","updated":"2025-11-12T03:51:36.366Z","comments":true,"path":"2025/11/12/随机信号处理-功率谱/","permalink":"https://www.yechenblog.top/2025/11/12/%E9%9A%8F%E6%9C%BA%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86-%E5%8A%9F%E7%8E%87%E8%B0%B1/","excerpt":"只为了考试！ 过程的一些数字特征 1. 均值 * 若功率谱连续则均值为0 2. 自相关函数和互相关函数 * 自相关 \\(R_{X}(\\tau) = \\mathbb{E}[X(t)X(t+\\tau)]\\) * 互相关 \\(R_{XY}(\\tau) = \\mathbb{E}[X(t)Y(t+\\tau)]\\) 3. 自相关系数 * def: \\(\\rho_X(\\tau)=\\frac{R_X(\\tau)}{R_X(0)},\\qquad \\rho_X(0)=1\\) 4. 方差/协方差 * 方差计算公式: \\(Var(X) =","text":"只为了考试！ 过程的一些数字特征 均值 若功率谱连续则均值为0 自相关函数和互相关函数 自相关 \\(R_{X}(\\tau) = \\mathbb{E}[X(t)X(t+\\tau)]\\) 互相关 \\(R_{XY}(\\tau) = \\mathbb{E}[X(t)Y(t+\\tau)]\\) 自相关系数 def: \\(\\rho_X(\\tau)=\\frac{R_X(\\tau)}{R_X(0)},\\qquad \\rho_X(0)=1\\) 方差/协方差 方差计算公式: \\(Var(X) = R_{X}(0) - m_{X}^2 = E[(X - E(X))^2]\\) 协方差计算公式: \\(\\mathrm{Cov}(X,Y)=\\mathbb{E}\\!\\left[(X-\\mu_X)(Y-\\mu_Y)\\right]\\) 自协方差和相关函数的关系: \\(R_X(\\tau) = m_X^2 + C_X(\\tau)\\) 相关时间 def: \\(\\tau_c=\\int_{0}^{\\infty}\\rho_X(\\tau)\\,d\\tau\\) 平均功率 \\(P_{\\text{avg}}=\\mathbb{E}[X^2(t)]=R_X(0)\\) 总功率 \\(P_{\\text{total}}=P_{\\text{DC}}+P_{\\text{AC}} = m_X^2 + \\big(R_X(0)-m_X^2\\big) = m_X^2 + \\sigma_X^2\\) 直流功率 交流功率 proof(1): 宽平稳过程 经常用到的公式: 三角形的和差化积 功率谱密度 常用性质: 频域时移 def: 对自相关函数/互相关函数做傅立叶变换得到功率谱密度 白噪声","categories":[{"name":"本科课程","slug":"本科课程","permalink":"https://www.yechenblog.top/categories/%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/"},{"name":"随机信号处理","slug":"本科课程/随机信号处理","permalink":"https://www.yechenblog.top/categories/%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/%E9%9A%8F%E6%9C%BA%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"}],"tags":[{"name":"本科课程","slug":"本科课程","permalink":"https://www.yechenblog.top/tags/%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/"},{"name":"随机信号处理","slug":"随机信号处理","permalink":"https://www.yechenblog.top/tags/%E9%9A%8F%E6%9C%BA%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"}]},{"title":"初识GTKWAVE","slug":"初识GTKWAVE","date":"2025-11-08T02:20:20.000Z","updated":"2025-11-12T13:04:39.806Z","comments":true,"path":"2025/11/08/初识GTKWAVE/","permalink":"https://www.yechenblog.top/2025/11/08/%E5%88%9D%E8%AF%86GTKWAVE/","excerpt":"编写testbench生成仿真文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include #include #include // 包含顶层模块的头文件 #include \"Vtop.h\" #include \"verilated.h\" // 生成vcd格式的仿真文件所需头文件 #include \"verilated_vcd_c.h\"","text":"编写testbench生成仿真文件 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;assert.h&gt;// 包含顶层模块的头文件#include \"Vtop.h\"#include \"verilated.h\"// 生成vcd格式的仿真文件所需头文件#include \"verilated_vcd_c.h\"int main(int argc, char** argv) { VerilatedContext* contextp = new VerilatedContext; // 创建一个上下文对象 VerilatedVcdC *tfp = new VerilatedVcdC; //创建一个VCD对象指针 contextp-&gt;commandArgs(argc, argv); Vtop* top = new Vtop{contextp}; // 在heap上构造一个对象 {}列表初始化 contextp-&gt;traceEverOn(true); // 打开上下文追踪 top-&gt;trace(tfp, 0); tfp-&gt;open(\"wave.vcd\"); //保存波形文件的位置 // 若上下文标记未完成，则一直循环 while (!contextp-&gt;gotFinish()) { int a = rand() &amp; 1; int b = rand() &amp; 1; // 对top module的input进行复制 top-&gt;a = a; top-&gt;b = b; // 更新output top-&gt;eval(); printf(\"a = %d, b = %d, f = %d\\n\", a, b, top-&gt;f); assert(top-&gt;f == (a ^ b)); // 写入wave.vcd tfp-&gt;dump(contextp-&gt;time()); // 增加上下文的时间 contextp-&gt;timeInc(1); if (contextp-&gt;time() &gt; 3) { contextp-&gt;gotFinish(true); //当上下文的时间超过3时标记完成 } } // 释放heap上面的对象 delete top; delete contextp; tfp-&gt;close(); return 0;} tips: 若要生成VCD文件 打开上下文中的traceOn 将输入输出写进VCD对象中 通过VCD对象写入文件 编译时请加上-trace","categories":[{"name":"一生一芯","slug":"一生一芯","permalink":"https://www.yechenblog.top/categories/%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF/"}],"tags":[{"name":"一生一芯","slug":"一生一芯","permalink":"https://www.yechenblog.top/tags/%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF/"},{"name":"工具","slug":"工具","permalink":"https://www.yechenblog.top/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"初识Verilator","slug":"初识Verilator","date":"2025-11-07T14:57:00.000Z","updated":"2025-11-08T02:17:47.950Z","comments":true,"path":"2025/11/07/初识Verilator/","permalink":"https://www.yechenblog.top/2025/11/07/%E5%88%9D%E8%AF%86Verilator/","excerpt":"Verilator的工作原理 * 我们需要使用 C++ 编写激励文件。显然，我们不能在 testbench 中直接调用我们 .v 中的模块，所以我们要通过 Verilator 将其转化为 C++ 文件再进行调用，Verilator 为我们提供了顶层模块输入/输出引脚的接口，使我们得以对顶层模块的输入信号赋值或读取其输出信号。 * Verilator 会生成一个 Makefile 脚本，利用 GCC 等编译器将生成的 C++ 文件和我们编写的激励文件编译成成用于仿真的可执行文件。 Verilator Files RTFM Verilator Comma","text":"Verilator的工作原理 我们需要使用 C++ 编写激励文件。显然，我们不能在 testbench 中直接调用我们 .v 中的模块，所以我们要通过 Verilator 将其转化为 C++ 文件再进行调用，Verilator 为我们提供了顶层模块输入/输出引脚的接口，使我们得以对顶层模块的输入信号赋值或读取其输出信号。 Verilator 会生成一个 Makefile 脚本，利用 GCC 等编译器将生成的 C++ 文件和我们编写的激励文件编译成成用于仿真的可执行文件。 Verilator Files RTFM Verilator Command shell1man verilator verilation(生成可供调用的 C++ 文件) shell1&nbsp;verilator --cc [--top &lt;top-name&gt;] VerilogSourcefile --cc:指定将 Verilog 转化为 C++ 代码 --top:当有多个Verilog 源文件的时候需要指定顶层模块 -Wall:打开Verilator所有的警告 --Mdir &lt;directory&gt;: 更改output file的路径，默认路径是obj_dir 编写testbench 示例（双控开关） top.v1234567module top( input a, input b, output f); assign f = a ^ b;endmodule main.cpp123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;assert.h&gt;// 包含顶层模块的头文件#include \"Vtop.h\"#include \"verilated.h\"int main(int argc, char** argv) { VerilatedContext* contextp = new VerilatedContext; // 创建一个上下文对象 contextp-&gt;commandArgs(argc, argv); Vtop* top = new Vtop{contextp}; // 在heap上构造一个对象 {}列表初始化 // 若上下文标记未完成，则一直循环 while (!contextp-&gt;gotFinish()) { int a = rand() &amp; 1; int b = rand() &amp; 1; // 对top module的input进行复制 top-&gt;a = a; top-&gt;b = b; // 更新output top-&gt;eval(); printf(\"a = %d, b = %d, f = %d\\n\", a, b, top-&gt;f); assert(top-&gt;f == (a ^ b)); // 增加上下文的时间 contextp-&gt;timeInc(1); if (contextp-&gt;time() &gt; 3) { contextp-&gt;gotFinish(true); //当上下文的时间超过3时标记完成 } } // 释放heap上面的对象 delete top; delete contextp; return 0;} 生成可执行文件并运行 shell1&nbsp;verilator --cc -Wall [--top &lt;top-name&gt;] VerilogSourcefile -exe testbenchfile -exe:其实这步就是将testbenchfile加入到生成的Makefile中 -bulid:构建可执行文件（自动执行Makefile），我们可以后面手动构建如果不加这个option 手动构建可执行文件 shell1make -C obj_dir -f Vtop.mk Vtop -C: Change to directory dir before reading the makefiles or doing anything else. -f: Use file as a makefile 最后的Vtop是make要构建的目标(Target)","categories":[{"name":"一生一芯","slug":"一生一芯","permalink":"https://www.yechenblog.top/categories/%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF/"}],"tags":[{"name":"一生一芯","slug":"一生一芯","permalink":"https://www.yechenblog.top/tags/%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF/"},{"name":"工具","slug":"工具","permalink":"https://www.yechenblog.top/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"随记1","slug":"随记1","date":"2025-11-07T14:35:41.000Z","updated":"2025-11-07T14:35:41.202Z","comments":true,"path":"2025/11/07/随记1/","permalink":"https://www.yechenblog.top/2025/11/07/%E9%9A%8F%E8%AE%B01/","excerpt":"2025年11月7日晚 我常常想两年后的我会走上什么的路。考研上岸后读研究生？考研失败后找份工作？亦或者是二战？这样一看，考研对我来说是件很重要的事。 如果它对我很重要的话，为什么我现在就不开始准备呢？为什么还要浪费时间在做一生一芯上呢？我很纠结。学校课程的作业、家里的事、一生一芯、考研…花在这些事情上的时间往往不能平衡要有取舍。 现在支撑我做一生一芯的动力就是完成入学答辩了，毕竟也花了这么多时间在上面，也不知道是对还是错，希望以后的我不会对这个决定后悔吧！","text":"2025年11月7日晚 我常常想两年后的我会走上什么的路。考研上岸后读研究生？考研失败后找份工作？亦或者是二战？这样一看，考研对我来说是件很重要的事。 如果它对我很重要的话，为什么我现在就不开始准备呢？为什么还要浪费时间在做一生一芯上呢？我很纠结。学校课程的作业、家里的事、一生一芯、考研…花在这些事情上的时间往往不能平衡要有取舍。 现在支撑我做一生一芯的动力就是完成入学答辩了，毕竟也花了这么多时间在上面，也不知道是对还是错，希望以后的我不会对这个决定后悔吧！","categories":[{"name":"随记","slug":"随记","permalink":"https://www.yechenblog.top/categories/%E9%9A%8F%E8%AE%B0/"}],"tags":[{"name":"随记","slug":"随记","permalink":"https://www.yechenblog.top/tags/%E9%9A%8F%E8%AE%B0/"}]},{"title":"信息论与编码2","slug":"信息论与编码2","date":"2025-11-07T10:09:13.000Z","updated":"2025-11-11T14:26:27.551Z","comments":true,"path":"2025/11/07/信息论与编码2/","permalink":"https://www.yechenblog.top/2025/11/07/%E4%BF%A1%E6%81%AF%E8%AE%BA%E4%B8%8E%E7%BC%96%E7%A0%812/","excerpt":"联合熵、条件熵、熵 \\[ H(X, Y) = H(X) + H (Y|X)\\] proof: \\[ \\begin{aligned} H(X,Y) &amp;= -\\sum_{x,y} p(x,y)\\,\\log p(x,y) \\\\ &amp;= -\\sum_{x,y} p(x,y)\\,\\log\\!\\big(p(x)\\,p(y\\mid x)\\big) \\\\ &amp;= -\\sum_{x,y} p(x,y)\\,\\log p(x) \\;-\\; \\sum_{x,y} p(x,y)\\,\\log p(y\\mid x) \\\\ &amp;= -\\sum_{x} \\Big(\\sum_y p(x,y)\\Big)\\log p(x) \\;-\\;","text":"联合熵、条件熵、熵 \\[ H(X, Y) = H(X) + H (Y|X)\\] proof: \\[ \\begin{aligned} H(X,Y) &amp;= -\\sum_{x,y} p(x,y)\\,\\log p(x,y) \\\\ &amp;= -\\sum_{x,y} p(x,y)\\,\\log\\!\\big(p(x)\\,p(y\\mid x)\\big) \\\\ &amp;= -\\sum_{x,y} p(x,y)\\,\\log p(x) \\;-\\; \\sum_{x,y} p(x,y)\\,\\log p(y\\mid x) \\\\ &amp;= -\\sum_{x} \\Big(\\sum_y p(x,y)\\Big)\\log p(x) \\;-\\; \\sum_x p(x)\\sum_y p(y\\mid x)\\,\\log p(y\\mid x) \\\\ &amp;= -\\sum_x p(x)\\log p(x) \\;+\\; \\sum_x p(x)\\,\\Big(-\\sum_y p(y\\mid x)\\log p(y\\mid x)\\Big) \\\\ &amp;= H(X) \\;+\\; \\sum_x p(x)\\,H(Y\\mid X{=}x) \\\\ &amp;= H(X)+H(Y\\mid X). \\end{aligned} \\] 记忆信源与无记忆信源 记忆信源：符号出现的概率与之前出现过的符号有关 无记忆信源：符号出现的概率与之前出现过符号的概率无关，只由符号自身的概率决定 tips: 离散信源的输出是一个符号表{x1, x2, x3…} 二重信源 def: 把原信源连续的两个符号当成一个新符号来看的那个新信源 马尔科夫信源 def: 即有记忆的离散信源 k阶马尔科夫信源：当前输出符号与前k个符号有关 状态转移 类似于FSM（有限状态机）。 wiki about FSM 马尔科夫信源熵 从一个状态到另一个状态发生转移并发出一个符号的熵 信源平均输出一个符号的熵（每个状态的熵的均值） 冗余度 def: \\[ R = 1 - \\frac{H(x)}{H_{max}}\\] 这里的 \\(\\frac{H(x)}{H_{max}}\\) 也叫信源效率 该值越大说明符号之间的相关性越强， 时间熵 def：平均每秒传递的信息量 (bit/s) formular： \\[ H_t = H(X) / E(T) \\] 其中\\(E(T)\\)为发送一个符号的平均时间，\\(H(X)\\)为信源熵即一个符号带有的信息量 编码 def: 为信源发出的每个符号进行编码 香农编码 如何进行香农编码: 哈夫曼编码 如何进行哈夫曼编码: wiki about Huffman 编码速率和编码效率 def: 编码速率即平均码长（bit/符号） \\[\\bar L = \\sum_{i=1}^{\\infty} p_i\\,l_i\\] def: 编码效率即信源熵/平均码长 \\[\\eta = \\frac{H(X)}{\\bar{L}}\\] 重要关系 \\(H(X) \\leq \\bar L\\) 即信源熵是平均码长的下界，信源熵是一个信源发出一个符号带来的平均不确定度/信息量（需要多少bit去表示这个符号的发生），而平均码长就是该编码表示一个符号的平均bits，当二者越接近说明这种编码方式的效率越高. 离散信道容量 Reveiw: 互信息(Mutual Information):是一个衡量“知道一个变量能减少另一个变量多少不确定性”的量，或者说二者共享的信息量。 数学定义为:\\(I(X;Y) = H(X) - H(X|Y)\\) 信道容量 目标 量 意义 想看输出反映输入多少 \\(I(X;Y)\\) 输入输出共享信息量 想找信道能力上限 \\(\\max_{p(x)} I(X;Y)\\) 最优输入分布下的最大共享信息量 数学定义: \\[C =\\max_{p(x)} I(X;Y)\\] 当信道矩阵(转移概率矩阵)对称时有: \\[C = log_{2}M - H(Y|X)\\] 理想观测器 什么是理想观测器(摘自ChatGPT5) 即根据条件概率选择当观测到某个y时，它的输入为x。 误判概率 设计的理想观测器的误判概率 Question 几何级数和几何级数求导求和？","categories":[{"name":"本科课程","slug":"本科课程","permalink":"https://www.yechenblog.top/categories/%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/"},{"name":"信息论与编码","slug":"本科课程/信息论与编码","permalink":"https://www.yechenblog.top/categories/%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E8%AE%BA%E4%B8%8E%E7%BC%96%E7%A0%81/"}],"tags":[{"name":"信息论与编码","slug":"信息论与编码","permalink":"https://www.yechenblog.top/tags/%E4%BF%A1%E6%81%AF%E8%AE%BA%E4%B8%8E%E7%BC%96%E7%A0%81/"},{"name":"本科课程","slug":"本科课程","permalink":"https://www.yechenblog.top/tags/%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/"}]},{"title":"4.1 Orthogonality of the four subspaces","slug":"4-1-Orthogonality-of-the-four-subspaces","date":"2025-11-06T16:50:01.000Z","updated":"2025-11-07T04:46:37.789Z","comments":true,"path":"2025/11/07/4-1-Orthogonality-of-the-four-subspaces/","permalink":"https://www.yechenblog.top/2025/11/07/4-1-Orthogonality-of-the-four-subspaces/","excerpt":"总结 对于这些内容接下来会一一解释 向量之间的正交 空间之间的正交 Def: 两个空间相互正交，即在这两个空间中，分别取任意一个向量，这两个向量都正交 Ex: 正交补空间 直观上：子空间\\(U\\)和正交补空间\\(U^{\\perp}\\)的和构成了整个空间，即该空间中的一个向量可以分解为\\(U\\)中的一个向量加上\\(U^\\perp\\)中的一个向量。 若\\(U\\)和\\(U\\perp\\)都为\\(R^n\\)的子空间，则有以下性质 1. \\(dimU + dimU^\\perp = n\\) 四个子空间之间的关系 1. 列空间和左零空间相互正交 2. 行空间和零空间相互正交","text":"总结 对于这些内容接下来会一一解释 向量之间的正交 空间之间的正交 Def: 两个空间相互正交，即在这两个空间中，分别取任意一个向量，这两个向量都正交 Ex: 正交补空间 直观上：子空间\\(U\\)和正交补空间\\(U^{\\perp}\\)的和构成了整个空间，即该空间中的一个向量可以分解为\\(U\\)中的一个向量加上\\(U^\\perp\\)中的一个向量。 若\\(U\\)和\\(U\\perp\\)都为\\(R^n\\)的子空间，则有以下性质 \\(dimU + dimU^\\perp = n\\) 四个子空间之间的关系 列空间和左零空间相互正交 行空间和零空间相互正交 方程\\(Ax=b\\)中的x位于\\(R^n\\)空间中 若矩阵A可逆，行空间中的所有向量与列空间中的向量一一对应 第二点的证明如下: 每一行与零空间的向量的点乘都为0 每个行向量之间的线性组合与零空间的点乘也为0 -&gt; 线性组合构成行空间中的任意一个向量 除此之外可以用代数的方法证明： \\[x^T(A^T y) = (Ax)^T y = 0\\] 第三第四点证明如下: 第三点很显然，因为x有n个分量，肯定在\\(R^n\\)中，根据正交补空间的性质，x就可以分解为\\(x = x_{row} + x_{null}\\) 故 \\[Ax = A(x_{row} + x_{null}) = Ax_{row} + 0\\] 当矩阵A不可逆的时候是做不到列空间中的向量与行空间中的向量一一对应的，因为存在着零空间的分量。但是当可逆的时候，零空间只有0。","categories":[{"name":"线性代数","slug":"线性代数","permalink":"https://www.yechenblog.top/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"}],"tags":[{"name":"线性代数","slug":"线性代数","permalink":"https://www.yechenblog.top/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"数学","slug":"数学","permalink":"https://www.yechenblog.top/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"helloworld","slug":"helloworld","date":"2025-11-06T13:51:27.000Z","updated":"2025-11-06T13:51:27.830Z","comments":true,"path":"2025/11/06/helloworld/","permalink":"https://www.yechenblog.top/2025/11/06/helloworld/","excerpt":"Hello world!","text":"Hello world!","categories":[],"tags":[]}],"categories":[{"name":"计组","slug":"计组","permalink":"https://www.yechenblog.top/categories/%E8%AE%A1%E7%BB%84/"},{"name":"一生一芯","slug":"一生一芯","permalink":"https://www.yechenblog.top/categories/%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF/"},{"name":"随记","slug":"随记","permalink":"https://www.yechenblog.top/categories/%E9%9A%8F%E8%AE%B0/"},{"name":"线性代数","slug":"线性代数","permalink":"https://www.yechenblog.top/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"本科课程","slug":"本科课程","permalink":"https://www.yechenblog.top/categories/%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/"},{"name":"随机信号处理","slug":"本科课程/随机信号处理","permalink":"https://www.yechenblog.top/categories/%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/%E9%9A%8F%E6%9C%BA%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"},{"name":"信息论与编码","slug":"本科课程/信息论与编码","permalink":"https://www.yechenblog.top/categories/%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/%E4%BF%A1%E6%81%AF%E8%AE%BA%E4%B8%8E%E7%BC%96%E7%A0%81/"}],"tags":[{"name":"计组","slug":"计组","permalink":"https://www.yechenblog.top/tags/%E8%AE%A1%E7%BB%84/"},{"name":"一生一芯","slug":"一生一芯","permalink":"https://www.yechenblog.top/tags/%E4%B8%80%E7%94%9F%E4%B8%80%E8%8A%AF/"},{"name":"随记","slug":"随记","permalink":"https://www.yechenblog.top/tags/%E9%9A%8F%E8%AE%B0/"},{"name":"Makefile","slug":"Makefile","permalink":"https://www.yechenblog.top/tags/Makefile/"},{"name":"线性代数","slug":"线性代数","permalink":"https://www.yechenblog.top/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"数学","slug":"数学","permalink":"https://www.yechenblog.top/tags/%E6%95%B0%E5%AD%A6/"},{"name":"本科课程","slug":"本科课程","permalink":"https://www.yechenblog.top/tags/%E6%9C%AC%E7%A7%91%E8%AF%BE%E7%A8%8B/"},{"name":"随机信号处理","slug":"随机信号处理","permalink":"https://www.yechenblog.top/tags/%E9%9A%8F%E6%9C%BA%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"},{"name":"工具","slug":"工具","permalink":"https://www.yechenblog.top/tags/%E5%B7%A5%E5%85%B7/"},{"name":"信息论与编码","slug":"信息论与编码","permalink":"https://www.yechenblog.top/tags/%E4%BF%A1%E6%81%AF%E8%AE%BA%E4%B8%8E%E7%BC%96%E7%A0%81/"}]}